<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>esp8266_Server</title>
      <link href="/2022/09/01/ESP8266-Server/"/>
      <url>/2022/09/01/ESP8266-Server/</url>
      
        <content type="html"><![CDATA[<h1 id="AP"><a href="#AP" class="headerlink" title="AP"></a>AP</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ESP8266WiFi.h&gt;        // 本程序使用ESP8266WiFi库</span><br><span class="line"> </span><br><span class="line">const char *ssid = &quot;ESP8266-kwx&quot;; // 这里定义将要建立的WiFi名称。此处以&quot;taichi-maker&quot;为示例</span><br><span class="line">                                   // 您可以将自己想要建立的WiFi名称填写入此处的双引号中</span><br><span class="line"> </span><br><span class="line">const char *password = &quot;123456788&quot;;  // 这里定义将要建立的WiFi密码。此处以12345678为示例</span><br><span class="line">                                    // 您可以将自己想要使用的WiFi密码放入引号内</span><br><span class="line">                                    // 如果建立的WiFi不要密码，则在双引号内不要填入任何信息</span><br><span class="line"> </span><br><span class="line">void setup() &#123;</span><br><span class="line">  Serial.begin(9600);              // 启动串口通讯</span><br><span class="line"> </span><br><span class="line">  WiFi.softAP(ssid, password);     // 此语句是重点。WiFi.softAP用于启动NodeMCU的AP模式。</span><br><span class="line">                                   // 括号中有两个参数，ssid是WiFi名。password是WiFi密码。</span><br><span class="line">                                   // 这两个参数具体内容在setup函数之前的位置进行定义。</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">  Serial.print(&quot;Access Point: &quot;);    // 通过串口监视器输出信息</span><br><span class="line">  Serial.println(ssid);              // 告知用户NodeMCU所建立的WiFi名</span><br><span class="line">  Serial.print(&quot;IP address: &quot;);      // 以及NodeMCU的IP地址</span><br><span class="line">  Serial.println(WiFi.softAPIP());   // 通过调用WiFi.softAPIP()可以得到NodeMCU的IP地址</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void loop() &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="esp8266-WebServer"><a href="#esp8266-WebServer" class="headerlink" title="esp8266_WebServer"></a>esp8266_WebServer</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;ESP8266WiFi.h&gt;        // 本程序使用 ESP8266WiFi库</span><br><span class="line">#include &lt;ESP8266WiFiMulti.h&gt;   //  ESP8266WiFiMulti库</span><br><span class="line">#include &lt;ESP8266WebServer.h&gt;   //  ESP8266WebServer库</span><br><span class="line"></span><br><span class="line">ESP8266WiFiMulti wifiMulti;     // 建立ESP8266WiFiMulti对象,对象名称是&#x27;wifiMulti&#x27;</span><br><span class="line"> </span><br><span class="line">ESP8266WebServer esp8266_server(80);// 建立ESP8266WebServer对象，对象名称为esp8266_server</span><br><span class="line">                                    // 括号中的数字是网路服务器响应http请求的端口号</span><br><span class="line">                                    // 网络服务器标准http端口号为80，因此这里使用80为端口号</span><br><span class="line"></span><br><span class="line">void setup(void)&#123;</span><br><span class="line">  Serial.begin(9600);          // 启动串口通讯</span><br><span class="line"></span><br><span class="line">  //通过addAp函数存储  WiFi名称       WiFi密码</span><br><span class="line">  wifiMulti.addAP(&quot;Redmi-1201&quot;, &quot;13975154788&quot;);  // 这三条语句通过调用函数addAP来记录3个不同的WiFi网络信息。</span><br><span class="line">  wifiMulti.addAP(&quot;taichi-maker2&quot;, &quot;87654321&quot;); // </span><br><span class="line">  wifiMulti.addAP(&quot;taichi-maker3&quot;, &quot;13572468&quot;); // 这3个网络的密码分别是123456789，87654321，13572468。</span><br><span class="line">                                                // 此处WiFi信息只是示例，请在使用时将需要连接的WiFi信息填入相应位置。</span><br><span class="line">                                                // 另外这里只存储了3个WiFi信息，您可以存储更多的WiFi信息在此处。</span><br><span class="line"></span><br><span class="line">  int i = 0;                                 </span><br><span class="line">  while (wifiMulti.run() != WL_CONNECTED) &#123;  // 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前</span><br><span class="line">    delay(1000);                             // 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU</span><br><span class="line">    Serial.print(i++); Serial.print(&#x27; &#x27;);    // 将会连接信号最强的那一个WiFi信号。</span><br><span class="line">  &#125;                                          // 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是</span><br><span class="line">                                             // 此处while循环判断是否跳出循环的条件。</span><br><span class="line"> </span><br><span class="line">  // WiFi连接成功后将通过串口监视器输出连接成功信息 </span><br><span class="line">  Serial.println(&#x27;\n&#x27;);                     // WiFi连接成功后</span><br><span class="line">  Serial.print(&quot;Connected to &quot;);            // NodeMCU将通过串口监视器输出。</span><br><span class="line">  Serial.println(WiFi.SSID());              // 连接的WiFI名称</span><br><span class="line">  Serial.print(&quot;IP address:\t&quot;);            // 以及</span><br><span class="line">  Serial.println(WiFi.localIP());           // NodeMCU的IP地址</span><br><span class="line">  </span><br><span class="line">//--------&quot;启动网络服务功能&quot;程序部分开始-------- //  此部分为程序为本示例程序重点1</span><br><span class="line">  esp8266_server.begin();                   //  详细讲解请参见太极创客网站《零基础入门学用物联网》</span><br><span class="line">  esp8266_server.on(&quot;/&quot;, handleRoot);       //  第3章-第2节 ESP8266-NodeMCU网络服务器-1</span><br><span class="line">  esp8266_server.on(&quot;/Hello&quot;, handleRoot2);</span><br><span class="line">  esp8266_server.onNotFound(handleNotFound);        </span><br><span class="line">//--------&quot;启动网络服务功能&quot;程序部分结束--------</span><br><span class="line">  Serial.println(&quot;HTTP esp8266_server started&quot;);//  告知用户ESP8266网络服务功能已经启动</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void loop(void)&#123;</span><br><span class="line">  esp8266_server.handleClient();     // 处理http服务器访问</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">                                                                    </span><br><span class="line">void handleRoot() &#123;   //处理网站根目录“/”的访问请求 </span><br><span class="line">  esp8266_server.send(200, &quot;text/plain&quot;, &quot;Hello from ESP8266&quot;);   // NodeMCU将调用此函数。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 设置处理404情况的函数&#x27;handleNotFound&#x27;</span><br><span class="line">void handleNotFound()&#123;                                        // 当浏览器请求的网络资源无法在服务器找到时，</span><br><span class="line">  esp8266_server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;);   // NodeMCU将调用此函数。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void handleRoot2()&#123;</span><br><span class="line">  esp8266_server.send(200,&quot;text/plain&quot;,&quot;Hello&quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="esp8266-WebServer-Button"><a href="#esp8266-WebServer-Button" class="headerlink" title="esp8266_WebServer_Button"></a>esp8266_WebServer_Button</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;ESP8266WiFi.h&gt;        // 本程序使用 ESP8266WiFi库</span><br><span class="line">#include &lt;ESP8266WiFiMulti.h&gt;   //  ESP8266WiFiMulti库</span><br><span class="line">#include &lt;ESP8266WebServer.h&gt;   //  ESP8266WebServer库</span><br><span class="line"> </span><br><span class="line">ESP8266WiFiMulti wifiMulti;     // 建立ESP8266WiFiMulti对象,对象名称是 &#x27;wifiMulti&#x27;</span><br><span class="line"> </span><br><span class="line">ESP8266WebServer esp8266_server(80);// 建立网络服务器对象，该对象用于响应HTTP请求。监听端口（80）</span><br><span class="line"> </span><br><span class="line">void setup(void)&#123;</span><br><span class="line">  Serial.begin(9600);   // 启动串口通讯</span><br><span class="line"> </span><br><span class="line">  pinMode(LED_BUILTIN, OUTPUT); //设置内置LED引脚为输出模式以便控制LED</span><br><span class="line">  </span><br><span class="line">  wifiMulti.addAP(&quot;Redmi-1201&quot;, &quot;13975154788&quot;); // 将需要连接的一系列WiFi ID和密码输入这里</span><br><span class="line">  wifiMulti.addAP(&quot;ssid_from_AP_2&quot;, &quot;your_password_for_AP_2&quot;); // ESP8266-NodeMCU再启动后会扫描当前网络</span><br><span class="line">  wifiMulti.addAP(&quot;ssid_from_AP_3&quot;, &quot;your_password_for_AP_3&quot;); // 环境查找是否有这里列出的WiFi ID。如果有</span><br><span class="line">  Serial.println(&quot;Connecting ...&quot;);                            // 则尝试使用此处存储的密码进行连接。</span><br><span class="line">  </span><br><span class="line">  int i = 0;                                 </span><br><span class="line">  while (wifiMulti.run() != WL_CONNECTED) &#123;  // 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前</span><br><span class="line">    delay(1000);                             // 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU</span><br><span class="line">    Serial.print(i++); Serial.print(&#x27; &#x27;);    // 将会连接信号最强的那一个WiFi信号。</span><br><span class="line">  &#125;                                          // 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是</span><br><span class="line">                                             // 此处while循环判断是否跳出循环的条件。</span><br><span class="line">  </span><br><span class="line">  // WiFi连接成功后将通过串口监视器输出连接成功信息 </span><br><span class="line">  Serial.println(&#x27;\n&#x27;);</span><br><span class="line">  Serial.print(&quot;Connected to &quot;);</span><br><span class="line">  Serial.println(WiFi.SSID());              // 通过串口监视器输出连接的WiFi名称</span><br><span class="line">  Serial.print(&quot;IP address:\t&quot;);</span><br><span class="line">  Serial.println(WiFi.localIP());           // 通过串口监视器输出ESP8266-NodeMCU的IP</span><br><span class="line"> </span><br><span class="line">  esp8266_server.begin();                           // 启动网站服务</span><br><span class="line">  esp8266_server.on(&quot;/&quot;, HTTP_GET, handleRoot);     // 设置服务器根目录即&#x27;/&#x27;的函数&#x27;handleRoot&#x27;</span><br><span class="line">  esp8266_server.on(&quot;/LED&quot;, HTTP_POST, handleLED);  // 设置处理LED控制请求的函数&#x27;handleLED&#x27;</span><br><span class="line">  esp8266_server.onNotFound(handleNotFound);        // 设置处理404情况的函数&#x27;handleNotFound&#x27;</span><br><span class="line"> </span><br><span class="line">  Serial.println(&quot;HTTP esp8266_server started&quot;);//  告知用户ESP8266网络服务功能已经启动</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void loop(void)&#123;</span><br><span class="line">  esp8266_server.handleClient();                     // 检查http服务器访问</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/*设置服务器根目录即&#x27;/&#x27;的函数&#x27;handleRoot&#x27;</span><br><span class="line">  该函数的作用是每当有客户端访问NodeMCU服务器根目录时，</span><br><span class="line">  NodeMCU都会向访问设备发送 HTTP 状态 200 (Ok) 这是send函数的第一个参数。</span><br><span class="line">  同时NodeMCU还会向浏览器发送HTML代码，以下示例中send函数中第三个参数，</span><br><span class="line">  也就是双引号中的内容就是NodeMCU发送的HTML代码。该代码可在网页中产生LED控制按钮。 </span><br><span class="line">  当用户按下按钮时，浏览器将会向NodeMCU的/LED页面发送HTTP请求，请求方式为POST。</span><br><span class="line">  NodeMCU接收到此请求后将会执行handleLED函数内容*/</span><br><span class="line">  </span><br><span class="line">void handleRoot() &#123;       </span><br><span class="line">  esp8266_server.send(200, &quot;text/html&quot;, &quot;&lt;form action=\&quot;/LED\&quot; method=\&quot;POST\&quot;&gt;&lt;input type=\&quot;submit\&quot; value=\&quot;Toggle LED\&quot;&gt;&lt;/form&gt;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//处理LED控制请求的函数&#x27;handleLED&#x27;</span><br><span class="line">void handleLED() &#123;                          </span><br><span class="line">  digitalWrite(LED_BUILTIN,!digitalRead(LED_BUILTIN));// 改变LED的点亮或者熄灭状态</span><br><span class="line">  esp8266_server.sendHeader(&quot;Location&quot;,&quot;/&quot;);          // 跳转回页面根目录</span><br><span class="line">  esp8266_server.send(303);                           // 发送Http相应代码303 跳转  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 设置处理404情况的函数&#x27;handleNotFound&#x27;</span><br><span class="line">void handleNotFound()&#123;</span><br><span class="line">  esp8266_server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;); // 发送 HTTP 状态 404 (未找到页面) 并向浏览器发送文字 &quot;404: Not found&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="esp8266-server-ReadPin"><a href="#esp8266-server-ReadPin" class="headerlink" title="esp8266_server_ReadPin"></a>esp8266_server_ReadPin</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;ESP8266WiFi.h&gt;        // 本程序使用 ESP8266WiFi库</span><br><span class="line">#include &lt;ESP8266WiFiMulti.h&gt;   //  ESP8266WiFiMulti库</span><br><span class="line">#include &lt;ESP8266WebServer.h&gt;   //  ESP8266WebServer库</span><br><span class="line"></span><br><span class="line">#define buttonPin D3            // 按钮引脚D3</span><br><span class="line"></span><br><span class="line">ESP8266WiFiMulti wifiMulti;     // 建立ESP8266WiFiMulti对象,对象名称是&#x27;wifiMulti&#x27;</span><br><span class="line"></span><br><span class="line">ESP8266WebServer esp8266_server(80);// 建立网络服务器对象，该对象用于响应HTTP请求。监听端口（80）</span><br><span class="line"> </span><br><span class="line">bool pinState;  // 存储引脚状态用变量</span><br><span class="line"></span><br><span class="line">void setup()&#123;</span><br><span class="line">  Serial.begin(9600);   // 启动串口通讯</span><br><span class="line"></span><br><span class="line">  pinMode(buttonPin, INPUT_PULLUP); // 将按键引脚设置为输入上拉模式</span><br><span class="line"></span><br><span class="line">  wifiMulti.addAP(&quot;Redmi-1201&quot;, &quot;13975154788&quot;); // 将需要连接的一系列WiFi ID和密码输入这里</span><br><span class="line">  wifiMulti.addAP(&quot;ssid_from_AP_2&quot;, &quot;your_password_for_AP_2&quot;); // ESP8266-NodeMCU再启动后会扫描当前网络</span><br><span class="line">  wifiMulti.addAP(&quot;ssid_from_AP_3&quot;, &quot;your_password_for_AP_3&quot;); // 环境查找是否有这里列出的WiFi ID。如果有</span><br><span class="line">  Serial.println(&quot;Connecting ...&quot;);                            // 则尝试使用此处存储的密码进行连接。</span><br><span class="line">  </span><br><span class="line">  int i = 0;                                 </span><br><span class="line">  while (wifiMulti.run() != WL_CONNECTED) &#123;  // 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前</span><br><span class="line">    delay(1000);                             // 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU</span><br><span class="line">    Serial.print(i++); Serial.print(&#x27; &#x27;);    // 将会连接信号最强的那一个WiFi信号。</span><br><span class="line">  &#125;                                          // 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是</span><br><span class="line">                                             // 此处while循环判断是否跳出循环的条件。</span><br><span class="line">  // WiFi连接成功后将通过串口监视器输出连接成功信息 </span><br><span class="line">  Serial.println(&#x27;\n&#x27;);                     // WiFi连接成功后</span><br><span class="line">  Serial.print(&quot;Connected to &quot;);            // NodeMCU将通过串口监视器输出。</span><br><span class="line">  Serial.println(WiFi.SSID());              // 连接的WiFI名称</span><br><span class="line">  Serial.print(&quot;IP address:\t&quot;);            // 以及</span><br><span class="line">  Serial.println(WiFi.localIP());           // NodeMCU的IP地址</span><br><span class="line">  </span><br><span class="line">  esp8266_server.begin();                   // 启动网站服务                </span><br><span class="line">  esp8266_server.on(&quot;/&quot;, handleRoot);       // 设置服务器根目录即&#x27;/&#x27;的函数&#x27;handleRoot&#x27;</span><br><span class="line">  esp8266_server.onNotFound(handleNotFound);// 设置处理404情况的函数&#x27;handleNotFound&#x27;        </span><br><span class="line"></span><br><span class="line">  Serial.println(&quot;HTTP esp8266_server started&quot;);//  告知用户ESP8266网络服务功能已经启动</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void loop()&#123;</span><br><span class="line">  esp8266_server.handleClient();     // 处理http服务器访问</span><br><span class="line">  pinState = digitalRead(buttonPin); // 获取引脚状态</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">                                                                 </span><br><span class="line">void handleRoot() &#123;   </span><br><span class="line">  String displayPinState;                   // 存储按键状态的字符串变量</span><br><span class="line">  </span><br><span class="line">  if(pinState == HIGH)&#123;                     // 当按键引脚D3为高电平</span><br><span class="line">    displayPinState = &quot;Button State: HIGH&quot;; // 字符串赋值高电平信息</span><br><span class="line">  &#125; else &#123;                                  // 当按键引脚D3为低电平</span><br><span class="line">    displayPinState = &quot;Button State: LOW&quot;;  // 字符串赋值低电平信息</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  esp8266_server.send(200, &quot;text/plain&quot;, displayPinState); </span><br><span class="line">                                            // 向浏览器发送按键状态信息  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 设置处理404情况的函数&#x27;handleNotFound&#x27;</span><br><span class="line">void handleNotFound()&#123;                                        // 当浏览器请求的网络资源无法在服务器找到时，</span><br><span class="line">  esp8266_server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;);   // NodeMCU将调用此函数。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="esp8266-server-ReadPin-Auto"><a href="#esp8266-server-ReadPin-Auto" class="headerlink" title="esp8266_server_ReadPin_Auto"></a>esp8266_server_ReadPin_Auto</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;ESP8266WiFi.h&gt;        // 本程序使用 ESP8266WiFi库</span><br><span class="line">#include &lt;ESP8266WiFiMulti.h&gt;   //  ESP8266WiFiMulti库</span><br><span class="line">#include &lt;ESP8266WebServer.h&gt;   //  ESP8266WebServer库</span><br><span class="line"></span><br><span class="line">#define buttonPin D3            // 按钮引脚D3</span><br><span class="line"></span><br><span class="line">ESP8266WiFiMulti wifiMulti;     // 建立ESP8266WiFiMulti对象,对象名称是&#x27;wifiMulti&#x27;</span><br><span class="line"> </span><br><span class="line">ESP8266WebServer esp8266_server(80);// 建立网络服务器对象，该对象用于响应HTTP请求。监听端口（80）</span><br><span class="line"> </span><br><span class="line">bool pinState;                      // 存储引脚状态用变量</span><br><span class="line"></span><br><span class="line">void setup()&#123;</span><br><span class="line">  Serial.begin(9600);          // 启动串口通讯</span><br><span class="line">  delay(10);</span><br><span class="line">  Serial.println(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">  pinMode(buttonPin, INPUT_PULLUP); // 将按键引脚设置为输入上拉模式</span><br><span class="line"></span><br><span class="line">  wifiMulti.addAP(&quot;Redmi-1201&quot;, &quot;13975154788&quot;); // 将需要连接的一系列WiFi ID和密码输入这里</span><br><span class="line">  wifiMulti.addAP(&quot;ssid_from_AP_2&quot;, &quot;your_password_for_AP_2&quot;); // ESP8266-NodeMCU在启动后会扫描当前网络</span><br><span class="line">  wifiMulti.addAP(&quot;ssid_from_AP_3&quot;, &quot;your_password_for_AP_3&quot;); // 环境查找是否有这里列出的WiFi ID。如果有</span><br><span class="line">  Serial.println(&quot;Connecting ...&quot;);                            // 则尝试使用此处存储的密码进行连接。</span><br><span class="line">                                                               // 另外这里只存储了3个WiFi信息，您可以存储更多</span><br><span class="line">                                                               // 的WiFi信息在此处。</span><br><span class="line">  int i = 0;                                 </span><br><span class="line">  while (wifiMulti.run() != WL_CONNECTED) &#123;  // 此处的wifiMulti.run()是重点。通过wifiMulti.run()，NodeMCU将会在当前</span><br><span class="line">    delay(1000);                             // 环境中搜索addAP函数所存储的WiFi。如果搜到多个存储的WiFi那么NodeMCU</span><br><span class="line">    Serial.print(i++); Serial.print(&#x27; &#x27;);    // 将会连接信号最强的那一个WiFi信号。</span><br><span class="line">  &#125;                                          // 一旦连接WiFI成功，wifiMulti.run()将会返回“WL_CONNECTED”。这也是</span><br><span class="line">                                             // 此处while循环判断是否跳出循环的条件。</span><br><span class="line">  // WiFi连接成功后将通过串口监视器输出连接成功信息 </span><br><span class="line">  Serial.println(&#x27;\n&#x27;);                     // WiFi连接成功后</span><br><span class="line">  Serial.print(&quot;Connected to &quot;);            // NodeMCU将通过串口监视器输出。</span><br><span class="line">  Serial.println(WiFi.SSID());              // 连接的WiFI名称</span><br><span class="line">  Serial.print(&quot;IP address:\t&quot;);            // 以及</span><br><span class="line">  Serial.println(WiFi.localIP());           // NodeMCU的IP地址</span><br><span class="line">  </span><br><span class="line">  esp8266_server.begin();                  </span><br><span class="line">  esp8266_server.on(&quot;/&quot;, handleRoot);      </span><br><span class="line">  esp8266_server.onNotFound(handleNotFound);        </span><br><span class="line"></span><br><span class="line">  Serial.println(&quot;HTTP esp8266_server started&quot;);//  告知用户ESP8266网络服务功能已经启动</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void loop()&#123;</span><br><span class="line">  esp8266_server.handleClient();     // 处理http服务器访问</span><br><span class="line">  pinState = digitalRead(buttonPin); // 获取引脚状态</span><br><span class="line">&#125;                                                                   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void handleRoot() &#123;   //处理网站目录“/”的访问请求 </span><br><span class="line">  esp8266_server.send(200, &quot;text/html&quot;, sendHTML(pinState));  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String sendHTML(bool buttonState)&#123;</span><br><span class="line">  </span><br><span class="line">  String htmlCode = &quot;&lt;!DOCTYPE html&gt; &lt;html&gt;\n&quot;;</span><br><span class="line">  htmlCode +=&quot;&lt;head&gt;&lt;meta http-equiv=&#x27;refresh&#x27; content=&#x27;5&#x27;/&gt;\n&quot;;</span><br><span class="line">  htmlCode +=&quot;&lt;title&gt;ESP8266 Butoon State&lt;/title&gt;\n&quot;;</span><br><span class="line">  htmlCode +=&quot;&lt;style&gt;html &#123; font-family: Helvetica; display: inline-block; margin: 0px auto; text-align: center;&#125;\n&quot;;</span><br><span class="line">  htmlCode +=&quot;body&#123;margin-top: 50px;&#125; h1 &#123;color: #444444;margin: 50px auto 30px;&#125; h3 &#123;color: #444444;margin-bottom: 50px;&#125;\n&quot;;</span><br><span class="line">  htmlCode +=&quot;&lt;/style&gt;\n&quot;;</span><br><span class="line">  htmlCode +=&quot;&lt;/head&gt;\n&quot;;</span><br><span class="line">  htmlCode +=&quot;&lt;body&gt;\n&quot;;</span><br><span class="line">  htmlCode +=&quot;&lt;h1&gt;ESP8266 BUTTON STATE&lt;/h1&gt;\n&quot;;</span><br><span class="line">  </span><br><span class="line">  if(buttonState)</span><br><span class="line">    &#123;htmlCode +=&quot;&lt;p&gt;Button Status: HIGH&lt;/p&gt;\n&quot;;&#125;</span><br><span class="line">  else</span><br><span class="line">    &#123;htmlCode +=&quot;&lt;p&gt;Button Status: LOW&lt;/p&gt;\n&quot;;&#125;</span><br><span class="line">    </span><br><span class="line">  htmlCode +=&quot;&lt;/body&gt;\n&quot;;</span><br><span class="line">  htmlCode +=&quot;&lt;/html&gt;\n&quot;;</span><br><span class="line">  </span><br><span class="line">  return htmlCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 设置处理404情况的函数&#x27;handleNotFound&#x27;</span><br><span class="line">void handleNotFound()&#123;                                        // 当浏览器请求的网络资源无法在服务器找到时，</span><br><span class="line">  esp8266_server.send(404, &quot;text/plain&quot;, &quot;404: Not found&quot;);   // NodeMCU将调用此函数。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Esp8266 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> esp8266 </tag>
            
            <tag> Sever </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>esp8266</title>
      <link href="/2022/08/27/ESP8266/"/>
      <url>/2022/08/27/ESP8266/</url>
      
        <content type="html"><![CDATA[<h1 id="全部引脚定义"><a href="#全部引脚定义" class="headerlink" title="全部引脚定义"></a>全部引脚定义</h1><img src="https://s2.loli.net/2022/08/27/bholLQcX5vIdDZt.png" ><h1 id="不可随意使用引脚"><a href="#不可随意使用引脚" class="headerlink" title="不可随意使用引脚"></a>不可随意使用引脚</h1><img src="https://s2.loli.net/2022/08/27/R28GIOAeUKr6Zpq.png" >]]></content>
      
      
      <categories>
          
          <category> Esp8266 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> esp8266 </tag>
            
            <tag> esp8266引脚 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32HAL_RTC</title>
      <link href="/2022/08/27/STM32HAL-RTC/"/>
      <url>/2022/08/27/STM32HAL-RTC/</url>
      
        <content type="html"><![CDATA[<h1 id="RTC"><a href="#RTC" class="headerlink" title="RTC"></a>RTC</h1><pre><code>可由 Vbat 供电 不会被复位键复位日历 无法断电保存rtc.h 自己添加MX_RTC_Init();需要自己添加RTC.c 中的MX_RTC_Init(void)函数有:</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(HAL_RTCEx_BKUPRead(&amp;hrtc, RTC_BKP_DR1)!=0x5050)    //判断是否时第一次上电 (默认是0xffff) 如果不是0x5050 则是第一次 就给初始化数据 否则就继承之前的</span><br><span class="line">&#123;</span><br><span class="line"> HAL_RTCEx_BKUPWrite(&amp;hrtc, RTC_BKP_DR1, 0x5050);</span><br><span class="line">    </span><br><span class="line"> 最后在后面加个&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>存放数据 先定义一个RTC_DateTypeDef rtcTime ;然后调用HAL_RTC_GetTime(&amp;hrtc, &amp;rtcTime, RTC_FORMAT_BIN);读取数据printf(&quot;%02d:%02d:%02d\r\n&quot;,GetTime.Hours, GetTime.Minutes, GetTime.Seconds);</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HAL_PWR_EnableBkUpAccess();         //取消备份区写保护</span><br><span class="line"></span><br><span class="line">__HAL_RCC_BKP_CLK_ENABLE();         //使能电源始终pwr</span><br><span class="line"></span><br><span class="line">__HAL_RCC_RTC_ENABLE();</span><br></pre></td></tr></table></figure><pre><code>需要先读出 时间 再读出日期</code></pre><h2 id="BKP"><a href="#BKP" class="headerlink" title="BKP"></a>BKP</h2><pre><code>10个16位寄存器可保存20个字节用户应用数据后备寄存器 可由 Vbat 供电 不会被复位键复位</code></pre><h3 id="HAL-RTCEx-BKUPRead"><a href="#HAL-RTCEx-BKUPRead" class="headerlink" title="HAL_RTCEx_BKUPRead()"></a>HAL_RTCEx_BKUPRead()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  HAL_RTCEx_BKUPWrite</span><br><span class="line">* @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains</span><br><span class="line">*                the configuration information for RTC.</span><br><span class="line">* @param  BackupRegister: RTC Backup data Register number.</span><br><span class="line">*          This parameter can be: RTC_BKP_DRx where x can be from 1 to 10 (or 42) to</span><br><span class="line">*                                 specify the register (depending devices).</span><br><span class="line">* @retval Read value</span><br></pre></td></tr></table></figure><h3 id="HAL-RTCEx-BKUPWrite"><a href="#HAL-RTCEx-BKUPWrite" class="headerlink" title="HAL_RTCEx_BKUPWrite"></a>HAL_RTCEx_BKUPWrite</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  HAL_RTCEx_BKUPWrite</span><br><span class="line">* @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains</span><br><span class="line">*                the configuration information for RTC.</span><br><span class="line">* @param  BackupRegister: RTC Backup data Register number.</span><br><span class="line">*          This parameter can be: RTC_BKP_DRx where x can be from 1 to 10 (or 42) to</span><br><span class="line">*                                 specify the register (depending devices).</span><br><span class="line">* @param  Data: Data to be written in the specified RTC Backup data register.</span><br><span class="line">* @retval None</span><br></pre></td></tr></table></figure><pre><code>例子:    HAL_RTCEx_BKUPRead(&amp;hrtc, RTC_BKP_DR1)!=0x5050)     HAL_RTCEx_BKUPWrite(&amp;hrtc, RTC_BKP_DR1, 0x5050);</code></pre>]]></content>
      
      
      <categories>
          
          <category> STM32_HAL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> HAL </tag>
            
            <tag> RTC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互联网基础</title>
      <link href="/2022/08/27/%E4%BA%92%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/08/27/%E4%BA%92%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h1><pre><code>局域网查看自己局域网 cmd-&gt;ipconfigipv4  ipv6 地址网关 WiFi 本身自己 就像海关 连接国与国之间 网关 连接网络与网络之间联网后会被赋相对互联网的ip 地址-&gt;DNS服务器-&gt;ip-&gt;服务器</code></pre><h1 id="互联网知识"><a href="#互联网知识" class="headerlink" title="互联网知识"></a>互联网知识</h1><h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><pre><code>WiFi 无线终端模式  接入点模式  混合模式</code></pre><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><pre><code>TCP/UDP   TCP 稳健   UDP 快 网游/在线视频</code></pre><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><pre><code>HTTP/FTP/...HTTP 有请求/响应</code></pre><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h4><img src="https://s2.loli.net/2022/08/27/8aFslempTXbjrx5.png" ><h5 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h5><pre><code>GET / HTTP / 1.1读取 / HTTP协议版本1.1GET 读取 POST 发送 </code></pre><h5 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h5><pre><code>Host:www.taichi-maker.com 网站地址User-Agent：Mozilla....  用户信息Accept:text/html 支持的格式Accept-Lauguage: zh-CN,zh;q=0.8 支持的语言ACcept-Encoding：gzip，deflate，sdch 支持的压缩编码格式Connection：Keep-Alive 是否继续保持连接</code></pre><h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><img src="https://s2.loli.net/2022/08/27/B4kWIAlQywh7Uiz.png" ><h5 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h5><pre><code>HTTP/1.1 200 OK 200 成功代码HTTP/1.1 404 NOT FOUND404 未找到代码状态码:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">100~199：成功接收请求，要求客户端继续提交下一次请求才能完成整个处理过程。</span><br><span class="line"></span><br><span class="line">200~299：成功接收请求并已完成整个处理过程。常用200</span><br><span class="line"></span><br><span class="line">300~399：完成请求，客户需进一步细化请求。</span><br><span class="line"></span><br><span class="line">400~499：客户端的请求有错误，常用404和403(403的含义是权限不够，服务器拒绝访问。)</span><br><span class="line"></span><br><span class="line">500~599：服务器端出现错误，常用500</span><br></pre></td></tr></table></figure></code></pre><h5 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h5><pre><code>Content-Type: text/html; charset = UTF-8响应体内容 : HTML网页; 编码字符集格式UTF-8Content-Type: image/jpeg  相应格式为jpeg图像 </code></pre>]]></content>
      
      
      <categories>
          
          <category> 互联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 互联网 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32HAL_EXTI</title>
      <link href="/2022/08/26/STM32HAL-EXTI/"/>
      <url>/2022/08/26/STM32HAL-EXTI/</url>
      
        <content type="html"><![CDATA[<h1 id="STM32外部中断通道"><a href="#STM32外部中断通道" class="headerlink" title="STM32外部中断通道"></a>STM32外部中断通道</h1><img src="https://s2.loli.net/2022/08/26/ySLWVwuMUBf5FgK.png" ><h1 id="STM32中断配置"><a href="#STM32中断配置" class="headerlink" title="STM32中断配置"></a>STM32中断配置</h1><img src="https://s2.loli.net/2022/08/26/6nGB4YMxp9hoWi2.png" ><h1 id="中断回调函数"><a href="#中断回调函数" class="headerlink" title="中断回调函数"></a>中断回调函数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)</span><br><span class="line"></span><br><span class="line">  * @param  GPIO_Pin: Specifies the pins connected EXTI line</span><br><span class="line">  * @retval None</span><br></pre></td></tr></table></figure><pre><code>例子:void HAL_GPIO_EXTI_Callback(uint16_t GPIO_PIN)&#123;    if(GPIO_PIN==KEY1_PIN)    &#123;     if(KEY_1())       &#123;          LED_1_Contrary();         &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> STM32_HAL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> HAL </tag>
            
            <tag> EXTI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32HAL_OLED移植</title>
      <link href="/2022/08/23/STM32HAL-OLED%E7%A7%BB%E6%A4%8D/"/>
      <url>/2022/08/23/STM32HAL-OLED%E7%A7%BB%E6%A4%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="HAL配置"><a href="#HAL配置" class="headerlink" title="HAL配置"></a>HAL配置</h1><img src = "https://s2.loli.net/2022/08/23/X7GtR6ajn1lgIY2.png"><h1 id="取模格式"><a href="#取模格式" class="headerlink" title="取模格式"></a>取模格式</h1><img src = "https://s2.loli.net/2022/08/23/vfU7gtaCjxeTdXE.png" width = "75%"><h1 id="简单做个效果"><a href="#简单做个效果" class="headerlink" title="简单做个效果"></a>简单做个效果</h1><img src = "https://s2.loli.net/2022/08/23/DVA6rW5uiCfGkFU.png" ><h1 id="主要更改部分"><a href="#主要更改部分" class="headerlink" title="主要更改部分"></a>主要更改部分</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define OLED_SCLK_Clr() HAL_GPIO_WritePin(GPIOA,GPIO_PIN_5,RESET) //GPIO_ResetBits(GPIOA,GPIO_Pin_5)//CLK</span><br><span class="line">#define OLED_SCLK_Set() HAL_GPIO_WritePin(GPIOA,GPIO_PIN_5,SET) //GPIO_SetBits(GPIOA,GPIO_Pin_5)</span><br><span class="line"></span><br><span class="line">#define OLED_SDIN_Clr() HAL_GPIO_WritePin(GPIOA,GPIO_PIN_7,RESET) //GPIO_ResetBits(GPIOA,GPIO_Pin_7)//DIN</span><br><span class="line">#define OLED_SDIN_Set() HAL_GPIO_WritePin(GPIOA,GPIO_PIN_7,SET) //GPIO_SetBits(GPIOA,GPIO_Pin_7)</span><br><span class="line"></span><br><span class="line">#define OLED_RST_Clr() HAL_GPIO_WritePin(GPIOB,GPIO_PIN_0,RESET) //GPIO_ResetBits(GPIOB,GPIO_Pin_0)//RES</span><br><span class="line">#define OLED_RST_Set() HAL_GPIO_WritePin(GPIOB,GPIO_PIN_0,SET) //GPIO_SetBits(GPIOB,GPIO_Pin_0)</span><br><span class="line"></span><br><span class="line">#define OLED_DC_Clr() HAL_GPIO_WritePin(GPIOB,GPIO_PIN_1,RESET) //GPIO_ResetBits(GPIOB,GPIO_Pin_1)//DC</span><br><span class="line">#define OLED_DC_Set() HAL_GPIO_WritePin(GPIOB,GPIO_PIN_1,SET) //GPIO_SetBits(GPIOB,GPIO_Pin_1)</span><br><span class="line">      </span><br><span class="line">#define OLED_CS_Clr()  HAL_GPIO_WritePin(GPIOA,GPIO_PIN_4,RESET) //GPIO_ResetBits(GPIOA,GPIO_Pin_4)//CS</span><br><span class="line">#define OLED_CS_Set()  HAL_GPIO_WritePin(GPIOA,GPIO_PIN_4,SET) //GPIO_SetBits(GPIOA,GPIO_Pin_4)</span><br></pre></td></tr></table></figure><h1 id="总体代码"><a href="#总体代码" class="headerlink" title="总体代码"></a>总体代码</h1><h2 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line">/* USER CODE BEGIN Header */</span><br><span class="line">/**</span><br><span class="line">  ******************************************************************************</span><br><span class="line">  * @file           : main.c</span><br><span class="line">  * @brief          : Main program body</span><br><span class="line">  ******************************************************************************</span><br><span class="line">  * @attention</span><br><span class="line">  *</span><br><span class="line">  * Copyright (c) 2022 STMicroelectronics.</span><br><span class="line">  * All rights reserved.</span><br><span class="line">  *</span><br><span class="line">  * This software is licensed under terms that can be found in the LICENSE file</span><br><span class="line">  * in the root directory of this software component.</span><br><span class="line">  * If no LICENSE file comes with this software, it is provided AS-IS.</span><br><span class="line">  *</span><br><span class="line">  ******************************************************************************</span><br><span class="line">  */</span><br><span class="line">/* USER CODE END Header */</span><br><span class="line">/* Includes ------------------------------------------------------------------*/</span><br><span class="line">#include &quot;main.h&quot;</span><br><span class="line">#include &quot;gpio.h&quot;</span><br><span class="line"></span><br><span class="line">/* Private includes ----------------------------------------------------------*/</span><br><span class="line">/* USER CODE BEGIN Includes */</span><br><span class="line">#include &quot;../../icode/OLED/oled.h&quot;</span><br><span class="line">/* USER CODE END Includes */</span><br><span class="line"></span><br><span class="line">/* Private typedef -----------------------------------------------------------*/</span><br><span class="line">/* USER CODE BEGIN PTD */</span><br><span class="line"></span><br><span class="line">/* USER CODE END PTD */</span><br><span class="line"></span><br><span class="line">/* Private define ------------------------------------------------------------*/</span><br><span class="line">/* USER CODE BEGIN PD */</span><br><span class="line">/* USER CODE END PD */</span><br><span class="line"></span><br><span class="line">/* Private macro -------------------------------------------------------------*/</span><br><span class="line">/* USER CODE BEGIN PM */</span><br><span class="line"></span><br><span class="line">/* USER CODE END PM */</span><br><span class="line"></span><br><span class="line">/* Private variables ---------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">/* USER CODE BEGIN PV */</span><br><span class="line"></span><br><span class="line">/* USER CODE END PV */</span><br><span class="line"></span><br><span class="line">/* Private function prototypes -----------------------------------------------*/</span><br><span class="line">void SystemClock_Config(void);</span><br><span class="line">/* USER CODE BEGIN PFP */</span><br><span class="line"></span><br><span class="line">/* USER CODE END PFP */</span><br><span class="line"></span><br><span class="line">/* Private user code ---------------------------------------------------------*/</span><br><span class="line">/* USER CODE BEGIN 0 */</span><br><span class="line"></span><br><span class="line">/* USER CODE END 0 */</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * @brief  The application entry point.</span><br><span class="line">  * @retval int</span><br><span class="line">  */</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  /* USER CODE BEGIN 1 */</span><br><span class="line"></span><br><span class="line">  /* USER CODE END 1 */</span><br><span class="line"></span><br><span class="line">  /* MCU Configuration--------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span><br><span class="line">  HAL_Init();</span><br><span class="line"></span><br><span class="line">  /* USER CODE BEGIN Init */</span><br><span class="line"></span><br><span class="line">  /* USER CODE END Init */</span><br><span class="line"></span><br><span class="line">  /* Configure the system clock */</span><br><span class="line">  SystemClock_Config();</span><br><span class="line"></span><br><span class="line">  /* USER CODE BEGIN SysInit */</span><br><span class="line"></span><br><span class="line">  /* USER CODE END SysInit */</span><br><span class="line"></span><br><span class="line">  /* Initialize all configured peripherals */</span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line">  /* USER CODE BEGIN 2 */</span><br><span class="line">  OLED_Init();</span><br><span class="line">  OLED_Clear();</span><br><span class="line">  /* USER CODE END 2 */</span><br><span class="line"></span><br><span class="line">  /* Infinite loop */</span><br><span class="line">  /* USER CODE BEGIN WHILE */</span><br><span class="line">  while (1)</span><br><span class="line">  &#123;</span><br><span class="line">  OLED_ShowCHinese(0,1,7);</span><br><span class="line">  OLED_ShowCHinese(18,1,8);</span><br><span class="line">  OLED_ShowCHinese(36,1,9);</span><br><span class="line">  OLED_ShowCHinese(54,1,10);</span><br><span class="line">  OLED_ShowString(72,1,&quot;!&quot;);</span><br><span class="line">  OLED_ShowString(24,3,&quot;HelloWorld!&quot;);</span><br><span class="line">    /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">    /* USER CODE BEGIN 3 */</span><br><span class="line">  &#125;</span><br><span class="line">  /* USER CODE END 3 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * @brief System Clock Configuration</span><br><span class="line">  * @retval None</span><br><span class="line">  */</span><br><span class="line">void SystemClock_Config(void)</span><br><span class="line">&#123;</span><br><span class="line">  RCC_OscInitTypeDef RCC_OscInitStruct = &#123;0&#125;;</span><br><span class="line">  RCC_ClkInitTypeDef RCC_ClkInitStruct = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">  /** Initializes the RCC Oscillators according to the specified parameters</span><br><span class="line">  * in the RCC_OscInitTypeDef structure.</span><br><span class="line">  */</span><br><span class="line">  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;</span><br><span class="line">  RCC_OscInitStruct.HSEState = RCC_HSE_ON;</span><br><span class="line">  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;</span><br><span class="line">  RCC_OscInitStruct.HSIState = RCC_HSI_ON;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;</span><br><span class="line">  if (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /** Initializes the CPU, AHB and APB buses clocks</span><br><span class="line">  */</span><br><span class="line">  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK</span><br><span class="line">                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;</span><br><span class="line">  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;</span><br><span class="line">  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;</span><br><span class="line">  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;</span><br><span class="line">  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;</span><br><span class="line"></span><br><span class="line">  if (HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* USER CODE BEGIN 4 */</span><br><span class="line"></span><br><span class="line">/* USER CODE END 4 */</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * @brief  This function is executed in case of error occurrence.</span><br><span class="line">  * @retval None</span><br><span class="line">  */</span><br><span class="line">void Error_Handler(void)</span><br><span class="line">&#123;</span><br><span class="line">  /* USER CODE BEGIN Error_Handler_Debug */</span><br><span class="line">  /* User can add his own implementation to report the HAL error return state */</span><br><span class="line">  __disable_irq();</span><br><span class="line">  while (1)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  /* USER CODE END Error_Handler_Debug */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#ifdef  USE_FULL_ASSERT</span><br><span class="line">/**</span><br><span class="line">  * @brief  Reports the name of the source file and the source line number</span><br><span class="line">  *         where the assert_param error has occurred.</span><br><span class="line">  * @param  file: pointer to the source file name</span><br><span class="line">  * @param  line: assert_param error line source number</span><br><span class="line">  * @retval None</span><br><span class="line">  */</span><br><span class="line">void assert_failed(uint8_t *file, uint32_t line)</span><br><span class="line">&#123;</span><br><span class="line">  /* USER CODE BEGIN 6 */</span><br><span class="line">  /* User can add his own implementation to report the file name and line number,</span><br><span class="line">     ex: printf(&quot;Wrong parameters value: file %s on line %d\r\n&quot;, file, line) */</span><br><span class="line">  /* USER CODE END 6 */</span><br><span class="line">&#125;</span><br><span class="line">#endif /* USE_FULL_ASSERT */</span><br></pre></td></tr></table></figure><h2 id="oled-h"><a href="#oled-h" class="headerlink" title="oled.h"></a>oled.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __OLED_H</span><br><span class="line">#define __OLED_H   </span><br><span class="line">#include &quot;stdlib.h&quot;    </span><br><span class="line">#include &quot;stm32f1xx_hal.h&quot; </span><br><span class="line">#include &quot;main.h&quot; </span><br><span class="line">#define u8 unsigned  char</span><br><span class="line">#define u32  unsigned long int</span><br><span class="line">#define OLED_MODE 0</span><br><span class="line">#define SIZE 16</span><br><span class="line">#define XLevelL0x00</span><br><span class="line">#define XLevelH0x10</span><br><span class="line">#define Max_Column128</span><br><span class="line">#define Max_Row64</span><br><span class="line">#defineBrightness0xFF </span><br><span class="line">#define X_WIDTH 128</span><br><span class="line">#define Y_WIDTH 64    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define OLED_SCLK_Clr() HAL_GPIO_WritePin(GPIOA,GPIO_PIN_5,RESET) //GPIO_ResetBits(GPIOA,GPIO_Pin_5)//CLK</span><br><span class="line">#define OLED_SCLK_Set() HAL_GPIO_WritePin(GPIOA,GPIO_PIN_5,SET) //GPIO_SetBits(GPIOA,GPIO_Pin_5)</span><br><span class="line"></span><br><span class="line">#define OLED_SDIN_Clr() HAL_GPIO_WritePin(GPIOA,GPIO_PIN_7,RESET) //GPIO_ResetBits(GPIOA,GPIO_Pin_7)//DIN</span><br><span class="line">#define OLED_SDIN_Set() HAL_GPIO_WritePin(GPIOA,GPIO_PIN_7,SET) //GPIO_SetBits(GPIOA,GPIO_Pin_7)</span><br><span class="line"></span><br><span class="line">#define OLED_RST_Clr() HAL_GPIO_WritePin(GPIOB,GPIO_PIN_0,RESET) //GPIO_ResetBits(GPIOB,GPIO_Pin_0)//RES</span><br><span class="line">#define OLED_RST_Set() HAL_GPIO_WritePin(GPIOB,GPIO_PIN_0,SET) //GPIO_SetBits(GPIOB,GPIO_Pin_0)</span><br><span class="line"></span><br><span class="line">#define OLED_DC_Clr() HAL_GPIO_WritePin(GPIOB,GPIO_PIN_1,RESET) //GPIO_ResetBits(GPIOB,GPIO_Pin_1)//DC</span><br><span class="line">#define OLED_DC_Set() HAL_GPIO_WritePin(GPIOB,GPIO_PIN_1,SET) //GPIO_SetBits(GPIOB,GPIO_Pin_1)</span><br><span class="line">      </span><br><span class="line">#define OLED_CS_Clr()  HAL_GPIO_WritePin(GPIOA,GPIO_PIN_4,RESET) //GPIO_ResetBits(GPIOA,GPIO_Pin_4)//CS</span><br><span class="line">#define OLED_CS_Set()  HAL_GPIO_WritePin(GPIOA,GPIO_PIN_4,SET) //GPIO_SetBits(GPIOA,GPIO_Pin_4)</span><br><span class="line"></span><br><span class="line">#define OLED_CMD  0</span><br><span class="line">#define OLED_DATA 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void OLED_WR_Byte(u8 dat,u8 cmd);    </span><br><span class="line">void OLED_Display_On(void);</span><br><span class="line">void OLED_Display_Off(void);          </span><br><span class="line">void OLED_Init(void);</span><br><span class="line">void OLED_Clear(void);</span><br><span class="line">void OLED_DrawPoint(u8 x,u8 y,u8 t);</span><br><span class="line">void OLED_Fill(u8 x1,u8 y1,u8 x2,u8 y2,u8 dot);</span><br><span class="line">void OLED_ShowChar(u8 x,u8 y,u8 chr);</span><br><span class="line">void OLED_ShowNum(u8 x,u8 y,u32 num,u8 len,u8 size);</span><br><span class="line">void OLED_ShowString(u8 x,u8 y, u8 *p); </span><br><span class="line">void OLED_Set_Pos(unsigned char x, unsigned char y);</span><br><span class="line">void OLED_ShowCHinese(u8 x,u8 y,u8 no);</span><br><span class="line">void OLED_DrawBMP(unsigned char x0, unsigned char y0,unsigned char x1, unsigned char y1,unsigned char BMP[]);</span><br><span class="line">#endif  </span><br></pre></td></tr></table></figure><h2 id="oled-c"><a href="#oled-c" class="headerlink" title="oled.c"></a>oled.c</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;oled.h&quot;</span><br><span class="line">#include &quot;stdlib.h&quot;</span><br><span class="line">#include &quot;oledfont.h&quot;   </span><br><span class="line"></span><br><span class="line">#define delay_ms HAL_Delay</span><br><span class="line">//[0]0 1 2 3 ... 127</span><br><span class="line">//[1]0 1 2 3 ... 127</span><br><span class="line">//[2]0 1 2 3 ... 127</span><br><span class="line">//[3]0 1 2 3 ... 127</span><br><span class="line">//[4]0 1 2 3 ... 127</span><br><span class="line">//[5]0 1 2 3 ... 127</span><br><span class="line">//[6]0 1 2 3 ... 127</span><br><span class="line">//[7]0 1 2 3 ... 127    </span><br><span class="line"></span><br><span class="line">#if OLED_MODE==1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void OLED_WR_Byte(u8 dat,u8 cmd)</span><br><span class="line">&#123;</span><br><span class="line">DATAOUT(dat);    </span><br><span class="line">if(cmd)</span><br><span class="line">  OLED_DC_Set();</span><br><span class="line">else </span><br><span class="line">  OLED_DC_Clr();   </span><br><span class="line">OLED_CS_Clr();</span><br><span class="line">OLED_WR_Clr(); </span><br><span class="line">OLED_WR_Set();</span><br><span class="line">OLED_CS_Set();  </span><br><span class="line">OLED_DC_Set(); </span><br><span class="line">&#125;         </span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void OLED_WR_Byte(u8 dat,u8 cmd)</span><br><span class="line">&#123;</span><br><span class="line">u8 i;  </span><br><span class="line">if(cmd)</span><br><span class="line">  OLED_DC_Set();</span><br><span class="line">else </span><br><span class="line">  OLED_DC_Clr();  </span><br><span class="line">OLED_CS_Clr();</span><br><span class="line">for(i=0;i&lt;8;i++)</span><br><span class="line">&#123;  </span><br><span class="line">OLED_SCLK_Clr();</span><br><span class="line">if(dat&amp;0x80)</span><br><span class="line">   OLED_SDIN_Set();</span><br><span class="line">else </span><br><span class="line">   OLED_SDIN_Clr();</span><br><span class="line">OLED_SCLK_Set();</span><br><span class="line">dat&lt;&lt;=1;   </span><br><span class="line">&#125;   </span><br><span class="line">OLED_CS_Set();</span><br><span class="line">OLED_DC_Set();     </span><br><span class="line">&#125; </span><br><span class="line">#endif</span><br><span class="line">void OLED_Set_Pos(unsigned char x, unsigned char y) </span><br><span class="line">&#123; </span><br><span class="line">OLED_WR_Byte(0xb0+y,OLED_CMD);</span><br><span class="line">OLED_WR_Byte(((x&amp;0xf0)&gt;&gt;4)|0x10,OLED_CMD);</span><br><span class="line">OLED_WR_Byte((x&amp;0x0f)|0x01,OLED_CMD); </span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void OLED_Display_On(void)</span><br><span class="line">&#123;</span><br><span class="line">OLED_WR_Byte(0X8D,OLED_CMD);  //SET DCDC</span><br><span class="line">OLED_WR_Byte(0X14,OLED_CMD);  //DCDC ON</span><br><span class="line">OLED_WR_Byte(0XAF,OLED_CMD);  //DISPLAY ON</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void OLED_Display_Off(void)</span><br><span class="line">&#123;</span><br><span class="line">OLED_WR_Byte(0X8D,OLED_CMD);  //SET DCDC</span><br><span class="line">OLED_WR_Byte(0X10,OLED_CMD);  //DCDC OFF</span><br><span class="line">OLED_WR_Byte(0XAE,OLED_CMD);  //DISPLAY OFF</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">void OLED_Clear(void)  </span><br><span class="line">&#123;  </span><br><span class="line">u8 i,n;    </span><br><span class="line">for(i=0;i&lt;8;i++)  </span><br><span class="line">&#123;  </span><br><span class="line">OLED_WR_Byte (0xb0+i,OLED_CMD);</span><br><span class="line">OLED_WR_Byte (0x00,OLED_CMD);</span><br><span class="line">OLED_WR_Byte (0x10,OLED_CMD);</span><br><span class="line">for(n=0;n&lt;128;n++)OLED_WR_Byte(0,OLED_DATA); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void OLED_ShowChar(u8 x,u8 y,u8 chr)</span><br><span class="line">&#123;      </span><br><span class="line">unsigned char c=0,i=0;</span><br><span class="line">c=chr-&#x27; &#x27;;</span><br><span class="line">if(x&gt;Max_Column-1)&#123;x=0;y=y+2;&#125;</span><br><span class="line">if(SIZE ==16)</span><br><span class="line">&#123;</span><br><span class="line">OLED_Set_Pos(x,y);</span><br><span class="line">for(i=0;i&lt;8;i++)</span><br><span class="line">OLED_WR_Byte(F8X16[c*16+i],OLED_DATA);</span><br><span class="line">OLED_Set_Pos(x,y+1);</span><br><span class="line">for(i=0;i&lt;8;i++)</span><br><span class="line">OLED_WR_Byte(F8X16[c*16+i+8],OLED_DATA);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">OLED_Set_Pos(x,y+1);</span><br><span class="line">for(i=0;i&lt;6;i++)</span><br><span class="line">OLED_WR_Byte(F6x8[c][i],OLED_DATA);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u32 oled_pow(u8 m,u8 n)</span><br><span class="line">&#123;</span><br><span class="line">u32 result=1; </span><br><span class="line">while(n--)result*=m;    </span><br><span class="line">return result;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void OLED_ShowNum(u8 x,u8 y,u32 num,u8 len,u8 size)</span><br><span class="line">&#123;         </span><br><span class="line">u8 t,temp;</span><br><span class="line">u8 enshow=0;   </span><br><span class="line">for(t=0;t&lt;len;t++)</span><br><span class="line">&#123;</span><br><span class="line">temp=(num/oled_pow(10,len-t-1))%10;</span><br><span class="line">if(enshow==0&amp;&amp;t&lt;(len-1))</span><br><span class="line">&#123;</span><br><span class="line">if(temp==0)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowChar(x+(size/2)*t,y,&#x27; &#x27;);</span><br><span class="line">continue;</span><br><span class="line">&#125;else enshow=1; </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"> OLED_ShowChar(x+(size/2)*t,y,temp+&#x27;0&#x27;); </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void OLED_ShowString(u8 x,u8 y,u8 *chr)</span><br><span class="line">&#123;</span><br><span class="line">unsigned char j=0;</span><br><span class="line">while (chr[j]!=&#x27;\0&#x27;)</span><br><span class="line">&#123;OLED_ShowChar(x,y,chr[j]);</span><br><span class="line">x+=8;</span><br><span class="line">if(x&gt;120)&#123;x=0;y+=2;&#125;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void OLED_ShowCHinese(u8 x,u8 y,u8 no)</span><br><span class="line">&#123;          </span><br><span class="line">u8 t,adder=0;</span><br><span class="line">OLED_Set_Pos(x,y);</span><br><span class="line">    for(t=0;t&lt;16;t++)</span><br><span class="line">&#123;</span><br><span class="line">OLED_WR_Byte(Hzk[2*no][t],OLED_DATA);</span><br><span class="line">adder+=1;</span><br><span class="line">     &#125;</span><br><span class="line">OLED_Set_Pos(x,y+1);</span><br><span class="line">    for(t=0;t&lt;16;t++)</span><br><span class="line">&#123;</span><br><span class="line">OLED_WR_Byte(Hzk[2*no+1][t],OLED_DATA);</span><br><span class="line">adder+=1;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void OLED_DrawBMP(unsigned char x0, unsigned char y0,unsigned char x1, unsigned char y1,unsigned char BMP[])</span><br><span class="line">&#123; </span><br><span class="line"> unsigned int j=0;</span><br><span class="line"> unsigned char x,y;</span><br><span class="line">  </span><br><span class="line">  if(y1%8==0) y=y1/8;      </span><br><span class="line">  else y=y1/8+1;</span><br><span class="line">for(y=y0;y&lt;y1;y++)</span><br><span class="line">&#123;</span><br><span class="line">OLED_Set_Pos(x0,y);</span><br><span class="line">    for(x=x0;x&lt;x1;x++)</span><br><span class="line">    &#123;      </span><br><span class="line">    OLED_WR_Byte(BMP[j++],OLED_DATA);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void OLED_Init(void)</span><br><span class="line">&#123; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    OLED_RST_Set();</span><br><span class="line">delay_ms(100);</span><br><span class="line">OLED_RST_Clr();</span><br><span class="line">delay_ms(200);</span><br><span class="line">OLED_RST_Set(); </span><br><span class="line">  </span><br><span class="line">OLED_WR_Byte(0xAE,OLED_CMD);//--turn off oled panel</span><br><span class="line">OLED_WR_Byte(0x00,OLED_CMD);//---set low column address</span><br><span class="line">OLED_WR_Byte(0x10,OLED_CMD);//---set high column address</span><br><span class="line">OLED_WR_Byte(0x40,OLED_CMD);//--set start line address  Set Mapping RAM Display Start Line (0x00~0x3F)</span><br><span class="line">OLED_WR_Byte(0x81,OLED_CMD);//--set contrast control register</span><br><span class="line">OLED_WR_Byte(0xCF,OLED_CMD); // Set SEG Output Current Brightness</span><br><span class="line">OLED_WR_Byte(0xA1,OLED_CMD);//--Set SEG/Column Mapping    </span><br><span class="line">OLED_WR_Byte(0xC8,OLED_CMD);//Set COM/Row Scan Direction   </span><br><span class="line">OLED_WR_Byte(0xA6,OLED_CMD);//--set normal display</span><br><span class="line">OLED_WR_Byte(0xA8,OLED_CMD);//--set multiplex ratio(1 to 64)</span><br><span class="line">OLED_WR_Byte(0x3f,OLED_CMD);//--1/64 duty</span><br><span class="line">OLED_WR_Byte(0xD3,OLED_CMD);//-set display offsetShift Mapping RAM Counter (0x00~0x3F)</span><br><span class="line">OLED_WR_Byte(0x00,OLED_CMD);//-not offset</span><br><span class="line">OLED_WR_Byte(0xd5,OLED_CMD);//--set display clock divide ratio/oscillator frequency</span><br><span class="line">OLED_WR_Byte(0x80,OLED_CMD);//--set divide ratio, Set Clock as 100 Frames/Sec</span><br><span class="line">OLED_WR_Byte(0xD9,OLED_CMD);//--set pre-charge period</span><br><span class="line">OLED_WR_Byte(0xF1,OLED_CMD);//Set Pre-Charge as 15 Clocks &amp; Discharge as 1 Clock</span><br><span class="line">OLED_WR_Byte(0xDA,OLED_CMD);//--set com pins hardware configuration</span><br><span class="line">OLED_WR_Byte(0x12,OLED_CMD);</span><br><span class="line">OLED_WR_Byte(0xDB,OLED_CMD);//--set vcomh</span><br><span class="line">OLED_WR_Byte(0x40,OLED_CMD);//Set VCOM Deselect Level</span><br><span class="line">OLED_WR_Byte(0x20,OLED_CMD);//-Set Page Addressing Mode (0x00/0x01/0x02)</span><br><span class="line">OLED_WR_Byte(0x02,OLED_CMD);//</span><br><span class="line">OLED_WR_Byte(0x8D,OLED_CMD);//--set Charge Pump enable/disable</span><br><span class="line">OLED_WR_Byte(0x14,OLED_CMD);//--set(0x10) disable</span><br><span class="line">OLED_WR_Byte(0xA4,OLED_CMD);// Disable Entire Display On (0xa4/0xa5)</span><br><span class="line">OLED_WR_Byte(0xA6,OLED_CMD);// Disable Inverse Display On (0xa6/a7) </span><br><span class="line">OLED_WR_Byte(0xAF,OLED_CMD);//--turn on oled panel</span><br><span class="line"></span><br><span class="line">OLED_WR_Byte(0xAF,OLED_CMD); /*display ON*/ </span><br><span class="line">OLED_Clear();</span><br><span class="line">OLED_Set_Pos(0,0); </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> STM32_HAL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> HAL </tag>
            
            <tag> SPI </tag>
            
            <tag> OLED </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32HAL_SPI</title>
      <link href="/2022/08/22/STM32HAL-SPI/"/>
      <url>/2022/08/22/STM32HAL-SPI/</url>
      
        <content type="html"><![CDATA[<h1 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,uint32_t Timeout)</span><br><span class="line"></span><br><span class="line">  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains</span><br><span class="line">  *               the configuration information for SPI module.</span><br><span class="line">  * @param  pTxData pointer to transmission data buffer</span><br><span class="line">  * @param  pRxData pointer to reception data buffer</span><br><span class="line">  * @param  Size amount of data to be sent and received</span><br><span class="line">  * @param  Timeout Timeout duration</span><br><span class="line">  * @retval HAL status</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>例子:HAL_SPI_TransmitReceive(&amp;hspi2,&amp;TxData,&amp;Rxdata,1,1000)SPI2   发送地址 接收地址  数量(单位byte)  溢出时间</code></pre>]]></content>
      
      
      <categories>
          
          <category> STM32_HAL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> HAL </tag>
            
            <tag> SPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32HAL_DMA</title>
      <link href="/2022/08/22/STM32HAL-DMA/"/>
      <url>/2022/08/22/STM32HAL-DMA/</url>
      
        <content type="html"><![CDATA[<h1 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h1><p>所有包括DMA工作的项目需要把DMA初始化函数放到前面！</p>]]></content>
      
      
      <categories>
          
          <category> STM32_HAL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> DMA </tag>
            
            <tag> HAL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32HAL_ADC</title>
      <link href="/2022/08/21/STM32HAL_ADC/"/>
      <url>/2022/08/21/STM32HAL_ADC/</url>
      
        <content type="html"><![CDATA[<h1 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h1><h2 id="ADC校准"><a href="#ADC校准" class="headerlink" title="ADC校准"></a>ADC校准</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef* hadc); //先校准ADC</span><br><span class="line">  * @param  hadc: This parameter can be </span><br><span class="line">            1  &amp;hadc1</span><br><span class="line">            2  &amp;hadc2</span><br><span class="line">  * @retval HAL status</span><br></pre></td></tr></table></figure><pre><code>  例子:  HAL_ADCEx_Calibration_Start(&amp;hadc1);  </code></pre><h2 id="软件开启一次转换"><a href="#软件开启一次转换" class="headerlink" title="软件开启一次转换"></a>软件开启一次转换</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uint16_t ADC_IN_1(void) //ADC采集程序</span><br><span class="line">&#123;</span><br><span class="line">   HAL_ADC_Start(&amp;hadc1); //开始ADC采集</span><br><span class="line">   HAL_ADC_PollForConversion(&amp;hadc1,500); //等待采集结束</span><br><span class="line">   if(HAL_IS_BIT_SET(HAL_ADC_GetState(&amp;hadc1), HAL_ADC_STATE_REG_EOC)) //读取ADC完成标志位</span><br><span class="line">   &#123;</span><br><span class="line">     return HAL_ADC_GetValue(&amp;hadc1); //读出ADC数值</span><br><span class="line">   &#125;</span><br><span class="line">     return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="DMA连续转换"><a href="#DMA连续转换" class="headerlink" title="DMA连续转换"></a>DMA连续转换</h2><pre><code>1 开启ADC 连续转换模式(不然转换一次就关闭了)2 循坏模式 半字数据</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HAL_ADC_Start_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length)</span><br><span class="line"></span><br><span class="line">  * @param  hadc: ADC handle</span><br><span class="line">  * @param  pData: The destination Buffer address.</span><br><span class="line">  * @param  Length: The length of data to be transferred from ADC peripheral to memory.</span><br><span class="line">  * @retval None</span><br><span class="line"></span><br><span class="line">  DMA must be configured to transfer size: half word.</span><br></pre></td></tr></table></figure><pre><code>例子: HAL_ADC_Start_DMA(&amp;hadc1, (uint32_t *) &amp; a1, 1);  adc1   转入a1中  每次连续转换1个</code></pre>]]></content>
      
      
      <categories>
          
          <category> STM32_HAL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> HAL </tag>
            
            <tag> ADC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32HAL-USART</title>
      <link href="/2022/08/21/STM32HAL-USART/"/>
      <url>/2022/08/21/STM32HAL-USART/</url>
      
        <content type="html"><![CDATA[<h1 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h1><h2 id="uart-串口发送数据"><a href="#uart-串口发送数据" class="headerlink" title="uart 串口发送数据"></a>uart 串口发送数据</h2><h3 id="HAL-UART-Transmit-huart-pData-Size-Timeout"><a href="#HAL-UART-Transmit-huart-pData-Size-Timeout" class="headerlink" title="HAL_UART_Transmit(huart, pData, Size, Timeout)"></a>HAL_UART_Transmit(huart, pData, Size, Timeout)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Transmit(huart, pData, Size, Timeout)</span><br><span class="line"> * @param  huart This parameter can be </span><br><span class="line">                 1  &amp;huart1 </span><br><span class="line">                 2  &amp;huart2    </span><br><span class="line">                 3  &amp;huart3</span><br><span class="line">           Pointer to a UART_HandleTypeDef structure that contains</span><br><span class="line">           the configuration information for the specified UART module.</span><br><span class="line"> * @param  pData Pointer to data buffer (u8 or u16 data elements).</span><br><span class="line"> * @param  Size  Amount of data elements (u8 or u16) to be sent</span><br><span class="line"> * @param  Timeout Timeout duration</span><br><span class="line"> * @retval HAL status</span><br></pre></td></tr></table></figure><pre><code>Size 参数 也可使用 sizeof()函数例子:HAL_UART_Transmit(&amp;huart1, (uint8_t*)&amp;&quot;Hello\r\n&quot;, 7, 0xffff);</code></pre><h2 id="uart-串口接收数据"><a href="#uart-串口接收数据" class="headerlink" title="uart 串口接收数据"></a>uart 串口接收数据</h2><h3 id="HAL-UART-Receive-IT-UART-HandleTypeDef-huart-uint8-t-pData-uint16-t-Size"><a href="#HAL-UART-Receive-IT-UART-HandleTypeDef-huart-uint8-t-pData-uint16-t-Size" class="headerlink" title="HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)"></a>HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)</h3><pre><code>  注意：HAL 默认不开启串口接收,所以需要先调用此函数开启接收</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)</span><br><span class="line"></span><br><span class="line">  * @param  huart This parameter can be </span><br><span class="line">            1   &amp;huart1</span><br><span class="line">            2   &amp;huart2</span><br><span class="line">            3   &amp;huart3</span><br><span class="line">  * @param  pData Pointer to data buffer (u8 or u16 data elements).</span><br><span class="line">  * @param  Size  Amount of data elements (u8 or u16) to be received.</span><br><span class="line">  * @retval HAL status</span><br></pre></td></tr></table></figure><pre><code>      例:HAL_UART_Receive_IT(&amp;huart1,(uint8_t *) &amp;USART1_NewData ,1);   //开启串口1 接收数据(一个字节)存放到USART1_NewData数组</code></pre><h3 id="中断回调函数"><a href="#中断回调函数" class="headerlink" title="中断回调函数"></a>中断回调函数</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><pre><code>与标准库不同,HAL库在处理中断时中断函数里面只有最简单的中断来源触发中断后，中断函数跳转到&quot;中断回调函数&quot;执行用户的代码</code></pre><h4 id="void-HAL-UART-RxCpltCallback-UART-HandleTypeDef-huart"><a href="#void-HAL-UART-RxCpltCallback-UART-HandleTypeDef-huart" class="headerlink" title="void  HAL_UART_RxCpltCallback(UART_HandleTypeDef  *huart)"></a>void  HAL_UART_RxCpltCallback(UART_HandleTypeDef  *huart)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void  HAL_UART_RxCpltCallback(UART_HandleTypeDef  *huart)</span><br><span class="line"></span><br><span class="line">  * @param  huart  This parameter can be </span><br><span class="line">                   1  &amp;husart1</span><br><span class="line">                   2  &amp;husart2</span><br><span class="line">                   3  &amp;husatr3</span><br><span class="line">  * @retval None</span><br></pre></td></tr></table></figure><p>例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">          void  HAL_UART_RxCpltCallback(UART_HandleTypeDef  *huart)//串口中断回调函数</span><br><span class="line">&#123;</span><br><span class="line">if(huart ==&amp;huart1)//判断中断来源（串口1）</span><br><span class="line">    &#123;</span><br><span class="line">       printf(&quot;%c&quot;,USART1_NewData); //把收到的数据以 a符号变量 发送回电脑</span><br><span class="line">       if((USART1_RX_STA&amp;0x8000)==0)&#123;//接收未完成</span><br><span class="line">           if(USART1_RX_STA&amp;0x4000)&#123;//接收到了0x0d</span><br><span class="line">               if(USART1_NewData!=0x0a)USART1_RX_STA=0;//接收错误,重新开始</span><br><span class="line">               else USART1_RX_STA|=0x8000;   //接收完成了</span><br><span class="line">           &#125;else&#123; //还没收到0X0D</span><br><span class="line">               if(USART1_NewData==0x0d)USART1_RX_STA|=0x4000;</span><br><span class="line">               else&#123;</span><br><span class="line">                  USART1_RX_BUF[USART1_RX_STA&amp;0X3FFF]=USART1_NewData; //将收到的数据放入数组</span><br><span class="line">                  USART1_RX_STA++;  //数据长度计数加1</span><br><span class="line">                  if(USART1_RX_STA&gt;(USART1_REC_LEN-1))USART1_RX_STA=0;//接收数据错误,重新开始接收</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       HAL_UART_Receive_IT(&amp;huart1,(uint8_t *)&amp;USART1_NewData,1); //再开启接收中断</span><br><span class="line">    &#125;</span><br><span class="line">    if(huart ==&amp;huart2)//判断中断来源(串口2)</span><br><span class="line">    &#123;</span><br><span class="line">       if(RS485orBT)&#123;//当RS485orBT标志位为1时是RS485模式，为0时是蓝牙模式</span><br><span class="line">       USART2_RX_BUF[0]=USART2_NewData;//将接收到的数据放入缓存数组（因只用到1个数据，所以只存放在数据[0]位置）</span><br><span class="line">       USART2_RX_STA++;//数据接收标志位加1</span><br><span class="line">       &#125;else&#123;</span><br><span class="line">       printf(&quot;%c&quot;,USART2_NewData); //把收到的数据以 a符号变量 发送回电脑</span><br><span class="line">       &#125;</span><br><span class="line">       HAL_UART_Receive_IT(&amp;huart2,(uint8_t *)&amp;USART2_NewData, 1); //再开启接收中断</span><br><span class="line">    &#125;</span><br><span class="line">if(huart ==&amp;huart3)//判断中断来源（串口3：WIFI模块）</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%c&quot;,USART3_NewData); //把收到的数据以 a符号变量 发送回电脑</span><br><span class="line">HAL_UART_Receive_IT(&amp;huart3,(uint8_t *)&amp;USART3_NewData,1); //再开启接收中断 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="重写printf函数"><a href="#重写printf函数" class="headerlink" title="重写printf函数"></a>重写printf函数</h1><pre><code> 1  Core-&gt;Src syscalls.c 属性-&gt;c/c++ Bulid-&gt;勾选&quot;Exclude resource from bulid&quot; （将文件不编译） 2  Core-&gt;Inc 添加retarget.h Core-&gt;Src 添加retarget.c 3   开启USART1 RetargetInit(&amp;huart1); 初始化uart1 printf(&quot;xxx&quot;)函数 串口发送xxx字样</code></pre><h1 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h1><pre><code>__weak 前缀是弱函数前缀 当不被定义时弱函数本身编译当被同名函数定义后弱函数不被编译类似于java的函数重载</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> HAL </tag>
            
            <tag> USART </tag>
            
            <tag> 重写printf函数 </tag>
            
            <tag> __week </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32HAL库函数</title>
      <link href="/2022/08/20/STM32HAL%E5%BA%93%E5%87%BD%E6%95%B0/"/>
      <url>/2022/08/20/STM32HAL%E5%BA%93%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="延迟函数"><a href="#延迟函数" class="headerlink" title="延迟函数"></a>延迟函数</h1><pre><code>    毫秒级延迟</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_Delay(uint32_t Delay)</span><br></pre></td></tr></table></figure><pre><code>uint32_t Delay:  This parameter can be (0..2^32)retval:          None</code></pre><h1 id="GPIO口控制"><a href="#GPIO口控制" class="headerlink" title="GPIO口控制"></a>GPIO口控制</h1><pre><code>多个IO口设置同样的状态,可以使用 &#39;|&#39; 连接</code></pre><h2 id="GPIO-Write"><a href="#GPIO-Write" class="headerlink" title="GPIO_Write"></a>GPIO_Write</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_GPIO_WritePin(GPIOx, GPIO_Pin, PinState) </span><br></pre></td></tr></table></figure><pre><code>GPIOx:         where x can be (A..G depending on device used)GPIO_Pin :     This parameter can be one of GPIO_PIN_x where x can be (0..15)PinState :     This parameter can be one of the GPIO_PinState enum values:                1    GPIO_PIN_RESET: to clear the port pin  (0)                2    GPIO_PIN_SET: to set the port pin      (1)retval:     None</code></pre><h2 id="GPIO-Read"><a href="#GPIO-Read" class="headerlink" title="GPIO_Read"></a>GPIO_Read</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_GPIO_ReadPin(GPIOx, GPIO_Pin) </span><br></pre></td></tr></table></figure><pre><code>GPIOx:         where x can be (A..G depending on device used)GPIO_Pin :     This parameter can be one of GPIO_PIN_x where x can be (0..15)retval:        1    GPIO_PIN_RESET        (0)               2    GPIO_PIN_SET      (1)</code></pre><h1 id="USART"><a href="#USART" class="headerlink" title="USART"></a>USART</h1><h2 id="USART-Send"><a href="#USART-Send" class="headerlink" title="USART_Send"></a>USART_Send</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)</span><br><span class="line"></span><br><span class="line">  * @param  huart Pointer to a UART_HandleTypeDef structure that contains</span><br><span class="line">  *               the configuration information for the specified UART module.</span><br><span class="line">  * @param  pData Pointer to data buffer (u8 or u16 data elements).</span><br><span class="line">  * @param  Size  Amount of data elements (u8 or u16) to be sent</span><br><span class="line">  * @param  Timeout Timeout duration</span><br><span class="line">  * @retval HAL status</span><br></pre></td></tr></table></figure><pre><code>HAL_UART_Transmit(&amp;huart1, (uint8_t*)&amp;&quot;Hello\r\n&quot;, 7, 0xffff);</code></pre><h2 id="USART-receive"><a href="#USART-receive" class="headerlink" title="USART_receive"></a>USART_receive</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)</span><br><span class="line"></span><br><span class="line">  * @param  huart Pointer to a UART_HandleTypeDef structure that contains</span><br><span class="line">  *               the configuration information for the specified UART module.</span><br><span class="line">  * @param  pData Pointer to data buffer (u8 or u16 data elements).</span><br><span class="line">  * @param  Size  Amount of data elements (u8 or u16) to be received.</span><br><span class="line">  * @param  Timeout Timeout duration</span><br><span class="line">  * @retval HAL status</span><br></pre></td></tr></table></figure><pre><code>HAL_UART_Receive_IT(&amp;huart3,(uint8_t *)&amp;USART1_NewData,1);</code></pre><h1 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h1><h2 id="ADC校准"><a href="#ADC校准" class="headerlink" title="ADC校准"></a>ADC校准</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef* hadc); //先校准ADC</span><br><span class="line">  * @param  hadc: This parameter can be </span><br><span class="line">            1  &amp;hadc1</span><br><span class="line">            2  &amp;hadc2</span><br><span class="line">  * @retval HAL status</span><br></pre></td></tr></table></figure><pre><code>  例子:  HAL_ADCEx_Calibration_Start(&amp;hadc1);  </code></pre><h2 id="软件开启一次转换"><a href="#软件开启一次转换" class="headerlink" title="软件开启一次转换"></a>软件开启一次转换</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uint16_t ADC_IN_1(void) //ADC采集程序</span><br><span class="line">&#123;</span><br><span class="line">   HAL_ADC_Start(&amp;hadc1); //开始ADC采集</span><br><span class="line">   HAL_ADC_PollForConversion(&amp;hadc1,500); //等待采集结束</span><br><span class="line">   if(HAL_IS_BIT_SET(HAL_ADC_GetState(&amp;hadc1), HAL_ADC_STATE_REG_EOC)) //读取ADC完成标志位</span><br><span class="line">   &#123;</span><br><span class="line">     return HAL_ADC_GetValue(&amp;hadc1); //读出ADC数值</span><br><span class="line">   &#125;</span><br><span class="line">     return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="DMA连续转换"><a href="#DMA连续转换" class="headerlink" title="DMA连续转换"></a>DMA连续转换</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HAL_ADC_Start_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length)</span><br><span class="line"></span><br><span class="line">  * @param  hadc: ADC handle</span><br><span class="line">  * @param  pData: The destination Buffer address.</span><br><span class="line">  * @param  Length: The length of data to be transferred from ADC peripheral to memory.</span><br><span class="line">  * @retval None</span><br><span class="line"></span><br><span class="line">  DMA must be configured to transfer size: half word.</span><br></pre></td></tr></table></figure><pre><code>例子: HAL_ADC_Start_DMA(&amp;hadc1, (uint32_t *) &amp; a1, 1);  adc1   转入a1中  每次连续转换1个</code></pre><h1 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,uint32_t Timeout)</span><br><span class="line"></span><br><span class="line">  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains</span><br><span class="line">  *               the configuration information for SPI module.</span><br><span class="line">  * @param  pTxData pointer to transmission data buffer</span><br><span class="line">  * @param  pRxData pointer to reception data buffer</span><br><span class="line">  * @param  Size amount of data to be sent and received</span><br><span class="line">  * @param  Timeout Timeout duration</span><br><span class="line">  * @retval HAL status</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> STM32_HAL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> HAL </tag>
            
            <tag> HAL库函数 </tag>
            
            <tag> GPIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32HAL_RCC</title>
      <link href="/2022/08/20/STM32HAL-RCC/"/>
      <url>/2022/08/20/STM32HAL-RCC/</url>
      
        <content type="html"><![CDATA[<h1 id="时钟树"><a href="#时钟树" class="headerlink" title="时钟树"></a>时钟树</h1><h2 id="时钟树总体框架"><a href="#时钟树总体框架" class="headerlink" title="时钟树总体框架"></a>时钟树总体框架</h2><img src = "https://s1.328888.xyz/2022/08/20/B7MDI.png" width="85%"><h2 id="时钟来源"><a href="#时钟来源" class="headerlink" title="时钟来源"></a>时钟来源</h2><img src = "https://s1.328888.xyz/2022/08/20/B7gvK.png" width="75%"><h1 id="MCO"><a href="#MCO" class="headerlink" title="MCO"></a>MCO</h1><h2 id="MCO作用"><a href="#MCO作用" class="headerlink" title="MCO作用"></a>MCO作用</h2><pre><code>    MCO：对外输出时钟     可以用作多个设备高度同步完成任务</code></pre><h2 id="MCO配置"><a href="#MCO配置" class="headerlink" title="MCO配置"></a>MCO配置</h2><img src = "https://s1.328888.xyz/2022/08/20/B7P5j.png" width="75%">  ]]></content>
      
      
      <categories>
          
          <category> STM32_HAL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> HAL </tag>
            
            <tag> RCC </tag>
            
            <tag> MCO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeIde界面汉化</title>
      <link href="/2022/08/20/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E6%B1%89%E5%8C%96/"/>
      <url>/2022/08/20/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E6%B1%89%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<img src="https://s1.328888.xyz/2022/08/20/BGQUR.png" width="50%"><img src="https://s1.328888.xyz/2022/08/20/BGzLU.png" width="50%"><img src="https://s1.328888.xyz/2022/08/20/BG7CB.png" width="50%"><img src="https://s1.328888.xyz/2022/08/20/B7II6.png" width="50%">]]></content>
      
      
      <categories>
          
          <category> STM32_HAL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> HAL </tag>
            
            <tag> STM32CubeIde </tag>
            
            <tag> 图形化编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文章演示</title>
      <link href="/2022/08/18/%E6%96%87%E7%AB%A0Test/"/>
      <url>/2022/08/18/%E6%96%87%E7%AB%A0Test/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006RKGBpgy1h0egvklcc4j30lo0v6n3d.jpg" alt="我是图片标识"></p><p><img src="https://s1.328888.xyz/2022/08/19/B6s0d.jpg" alt="imgloc图床测试"></p><img src="https://s1.328888.xyz/2022/08/19/B6s0d.jpg" width="50%" height="25%" />另一种测试 width和height后面的50%就是根据窗口的大小以一定的比例显示图片，是以width方向为准，并保持纵横比的，换句话说，把设置width的部分去掉，height的值改为任意百分比，显示的图像都是原图大小<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><p> 123</p><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p> 123</p><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p> 1322</p><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><p> 1233</p><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><p> 123</p><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><p> 123</p><h3 id="三级标题-1"><a href="#三级标题-1" class="headerlink" title="三级标题"></a>三级标题</h3><p> 1322</p><h4 id="四级标题-1"><a href="#四级标题-1" class="headerlink" title="四级标题"></a>四级标题</h4><p> 1233</p><p>下面是代码块测试</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span> ()&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>STM32-USART</title>
      <link href="/2022/08/21/STM32-USART/"/>
      <url>/2022/08/21/STM32-USART/</url>
      
        <content type="html"><![CDATA[<h1 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h1><h2 id="uart-串口发送数据"><a href="#uart-串口发送数据" class="headerlink" title="uart 串口发送数据"></a>uart 串口发送数据</h2><h3 id="HAL-UART-Transmit-huart-pData-Size-Timeout"><a href="#HAL-UART-Transmit-huart-pData-Size-Timeout" class="headerlink" title="HAL_UART_Transmit(huart, pData, Size, Timeout)"></a>HAL_UART_Transmit(huart, pData, Size, Timeout)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Transmit(huart, pData, Size, Timeout)</span><br><span class="line"> * @param  huart This parameter can be </span><br><span class="line">                 1  &amp;huart1 </span><br><span class="line">                 2  &amp;huart2    </span><br><span class="line">                 3  &amp;huart3</span><br><span class="line">           Pointer to a UART_HandleTypeDef structure that contains</span><br><span class="line">           the configuration information for the specified UART module.</span><br><span class="line"> * @param  pData Pointer to data buffer (u8 or u16 data elements).</span><br><span class="line"> * @param  Size  Amount of data elements (u8 or u16) to be sent</span><br><span class="line"> * @param  Timeout Timeout duration</span><br><span class="line"> * @retval HAL status</span><br></pre></td></tr></table></figure><pre><code>Size 参数 也可使用 sizeof()函数例子:HAL_UART_Transmit(&amp;huart1, (uint8_t*)&amp;&quot;Hello\r\n&quot;, 7, 0xffff);</code></pre><h2 id="uart-串口接收数据"><a href="#uart-串口接收数据" class="headerlink" title="uart 串口接收数据"></a>uart 串口接收数据</h2><h3 id="HAL-UART-Receive-IT-UART-HandleTypeDef-huart-uint8-t-pData-uint16-t-Size"><a href="#HAL-UART-Receive-IT-UART-HandleTypeDef-huart-uint8-t-pData-uint16-t-Size" class="headerlink" title="HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)"></a>HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)</h3><pre><code>  注意：HAL 默认不开启串口接收,所以需要先调用此函数开启接收</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)</span><br><span class="line"></span><br><span class="line">  * @param  huart This parameter can be </span><br><span class="line">            1   &amp;huart1</span><br><span class="line">            2   &amp;huart2</span><br><span class="line">            3   &amp;huart3</span><br><span class="line">  * @param  pData Pointer to data buffer (u8 or u16 data elements).</span><br><span class="line">  * @param  Size  Amount of data elements (u8 or u16) to be received.</span><br><span class="line">  * @retval HAL status</span><br></pre></td></tr></table></figure><pre><code>      例:HAL_UART_Receive_IT(&amp;huart1,(uint8_t *) &amp;USART1_NewData ,1);   //开启串口1 接收数据(一个字节)存放到USART1_NewData数组</code></pre><h3 id="中断回调函数"><a href="#中断回调函数" class="headerlink" title="中断回调函数"></a>中断回调函数</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><pre><code>与标准库不同,HAL库在处理中断时中断函数里面只有最简单的中断来源触发中断后，中断函数跳转到&quot;中断回调函数&quot;执行用户的代码</code></pre><h4 id="void-HAL-UART-RxCpltCallback-UART-HandleTypeDef-huart"><a href="#void-HAL-UART-RxCpltCallback-UART-HandleTypeDef-huart" class="headerlink" title="void  HAL_UART_RxCpltCallback(UART_HandleTypeDef  *huart)"></a>void  HAL_UART_RxCpltCallback(UART_HandleTypeDef  *huart)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void  HAL_UART_RxCpltCallback(UART_HandleTypeDef  *huart)</span><br><span class="line"></span><br><span class="line">  * @param  huart  This parameter can be </span><br><span class="line">                   1  &amp;husart1</span><br><span class="line">                   2  &amp;husart2</span><br><span class="line">                   3  &amp;husatr3</span><br><span class="line">  * @retval None</span><br></pre></td></tr></table></figure><p>例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">          void  HAL_UART_RxCpltCallback(UART_HandleTypeDef  *huart)//串口中断回调函数</span><br><span class="line">&#123;</span><br><span class="line">if(huart ==&amp;huart1)//判断中断来源（串口1）</span><br><span class="line">    &#123;</span><br><span class="line">       printf(&quot;%c&quot;,USART1_NewData); //把收到的数据以 a符号变量 发送回电脑</span><br><span class="line">       if((USART1_RX_STA&amp;0x8000)==0)&#123;//接收未完成</span><br><span class="line">           if(USART1_RX_STA&amp;0x4000)&#123;//接收到了0x0d</span><br><span class="line">               if(USART1_NewData!=0x0a)USART1_RX_STA=0;//接收错误,重新开始</span><br><span class="line">               else USART1_RX_STA|=0x8000;   //接收完成了</span><br><span class="line">           &#125;else&#123; //还没收到0X0D</span><br><span class="line">               if(USART1_NewData==0x0d)USART1_RX_STA|=0x4000;</span><br><span class="line">               else&#123;</span><br><span class="line">                  USART1_RX_BUF[USART1_RX_STA&amp;0X3FFF]=USART1_NewData; //将收到的数据放入数组</span><br><span class="line">                  USART1_RX_STA++;  //数据长度计数加1</span><br><span class="line">                  if(USART1_RX_STA&gt;(USART1_REC_LEN-1))USART1_RX_STA=0;//接收数据错误,重新开始接收</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       HAL_UART_Receive_IT(&amp;huart1,(uint8_t *)&amp;USART1_NewData,1); //再开启接收中断</span><br><span class="line">    &#125;</span><br><span class="line">    if(huart ==&amp;huart2)//判断中断来源(串口2)</span><br><span class="line">    &#123;</span><br><span class="line">       if(RS485orBT)&#123;//当RS485orBT标志位为1时是RS485模式，为0时是蓝牙模式</span><br><span class="line">       USART2_RX_BUF[0]=USART2_NewData;//将接收到的数据放入缓存数组（因只用到1个数据，所以只存放在数据[0]位置）</span><br><span class="line">       USART2_RX_STA++;//数据接收标志位加1</span><br><span class="line">       &#125;else&#123;</span><br><span class="line">       printf(&quot;%c&quot;,USART2_NewData); //把收到的数据以 a符号变量 发送回电脑</span><br><span class="line">       &#125;</span><br><span class="line">       HAL_UART_Receive_IT(&amp;huart2,(uint8_t *)&amp;USART2_NewData, 1); //再开启接收中断</span><br><span class="line">    &#125;</span><br><span class="line">if(huart ==&amp;huart3)//判断中断来源（串口3：WIFI模块）</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%c&quot;,USART3_NewData); //把收到的数据以 a符号变量 发送回电脑</span><br><span class="line">HAL_UART_Receive_IT(&amp;huart3,(uint8_t *)&amp;USART3_NewData,1); //再开启接收中断 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="重写printf函数"><a href="#重写printf函数" class="headerlink" title="重写printf函数"></a>重写printf函数</h1><pre><code> 1  Core-&gt;Src syscalls.c 属性-&gt;c/c++ Bulid-&gt;勾选&quot;Exclude resource from bulid&quot; （将文件不编译） 2  Core-&gt;Inc 添加retarget.h Core-&gt;Src 添加retarget.c 3   开启USART1 RetargetInit(&amp;huart1); 初始化uart1 printf(&quot;xxx&quot;)函数 串口发送xxx字样</code></pre><h1 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h1><pre><code>__weak 前缀是弱函数前缀 当不被定义时弱函数本身编译当被同名函数定义后弱函数不被编译类似于java的函数重载</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> USART </tag>
            
            <tag> 重写printf函数 </tag>
            
            <tag> __week </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32HAL库函数</title>
      <link href="/2022/08/20/STM32HAL%E5%BA%93%E5%87%BD%E6%95%B0/"/>
      <url>/2022/08/20/STM32HAL%E5%BA%93%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="延迟函数"><a href="#延迟函数" class="headerlink" title="延迟函数"></a>延迟函数</h1><pre><code>    毫秒级延迟</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_Delay(uint32_t Delay)</span><br></pre></td></tr></table></figure><pre><code>uint32_t Delay:  This parameter can be (0..2^32)retval:          None</code></pre><h1 id="GPIO口控制"><a href="#GPIO口控制" class="headerlink" title="GPIO口控制"></a>GPIO口控制</h1><pre><code>多个IO口设置同样的状态,可以使用 &#39;|&#39; 连接</code></pre><h2 id="GPIO-Write"><a href="#GPIO-Write" class="headerlink" title="GPIO_Write"></a>GPIO_Write</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_GPIO_WritePin(GPIOx, GPIO_Pin, PinState) </span><br></pre></td></tr></table></figure><pre><code>GPIOx:         where x can be (A..G depending on device used)GPIO_Pin :     This parameter can be one of GPIO_PIN_x where x can be (0..15)PinState :     This parameter can be one of the GPIO_PinState enum values:                1    GPIO_PIN_RESET: to clear the port pin  (0)                2    GPIO_PIN_SET: to set the port pin      (1)retval:     None</code></pre><h2 id="GPIO-Read"><a href="#GPIO-Read" class="headerlink" title="GPIO_Read"></a>GPIO_Read</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_GPIO_ReadPin(GPIOx, GPIO_Pin) </span><br></pre></td></tr></table></figure><pre><code>GPIOx:         where x can be (A..G depending on device used)GPIO_Pin :     This parameter can be one of GPIO_PIN_x where x can be (0..15)retval:        1    GPIO_PIN_RESET        (0)               2    GPIO_PIN_SET      (1)</code></pre>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> HAL库函数 </tag>
            
            <tag> GPIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32_RCC</title>
      <link href="/2022/08/20/stm32-RCC/"/>
      <url>/2022/08/20/stm32-RCC/</url>
      
        <content type="html"><![CDATA[<h1 id="时钟树"><a href="#时钟树" class="headerlink" title="时钟树"></a>时钟树</h1><h2 id="时钟树总体框架"><a href="#时钟树总体框架" class="headerlink" title="时钟树总体框架"></a>时钟树总体框架</h2><img src = "https://s1.328888.xyz/2022/08/20/B7MDI.png" width="85%"><h2 id="时钟来源"><a href="#时钟来源" class="headerlink" title="时钟来源"></a>时钟来源</h2><img src = "https://s1.328888.xyz/2022/08/20/B7gvK.png" width="75%"><h1 id="MCO"><a href="#MCO" class="headerlink" title="MCO"></a>MCO</h1><h2 id="MCO作用"><a href="#MCO作用" class="headerlink" title="MCO作用"></a>MCO作用</h2><pre><code>    MCO：对外输出时钟     可以用作多个设备高度同步完成任务</code></pre><h2 id="MCO配置"><a href="#MCO配置" class="headerlink" title="MCO配置"></a>MCO配置</h2><img src = "https://s1.328888.xyz/2022/08/20/B7P5j.png" width="75%">  ]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> RCC </tag>
            
            <tag> MCO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeIde界面汉化</title>
      <link href="/2022/08/20/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E6%B1%89%E5%8C%96/"/>
      <url>/2022/08/20/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E6%B1%89%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<img src="https://s1.328888.xyz/2022/08/20/BGQUR.png" width="50%"><img src="https://s1.328888.xyz/2022/08/20/BGzLU.png" width="50%"><img src="https://s1.328888.xyz/2022/08/20/BG7CB.png" width="50%"><img src="https://s1.328888.xyz/2022/08/20/B7II6.png" width="50%">]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> STM32CubeIde </tag>
            
            <tag> 图形化编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文章演示</title>
      <link href="/2022/08/18/%E6%96%87%E7%AB%A0Test/"/>
      <url>/2022/08/18/%E6%96%87%E7%AB%A0Test/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006RKGBpgy1h0egvklcc4j30lo0v6n3d.jpg" alt="我是图片标识"></p><p><img src="https://s1.328888.xyz/2022/08/19/B6s0d.jpg" alt="imgloc图床测试"></p><img src="https://s1.328888.xyz/2022/08/19/B6s0d.jpg" width="50%" height="25%" />另一种测试 width和height后面的50%就是根据窗口的大小以一定的比例显示图片，是以width方向为准，并保持纵横比的，换句话说，把设置width的部分去掉，height的值改为任意百分比，显示的图像都是原图大小<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><p> 123</p><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p> 123</p><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p> 1322</p><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><p> 1233</p><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><p> 123</p><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><p> 123</p><h3 id="三级标题-1"><a href="#三级标题-1" class="headerlink" title="三级标题"></a>三级标题</h3><p> 1322</p><h4 id="四级标题-1"><a href="#四级标题-1" class="headerlink" title="四级标题"></a>四级标题</h4><p> 1233</p><p>下面是代码块测试</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span> ()&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

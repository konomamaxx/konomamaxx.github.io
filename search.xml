<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>STC89C52RC_Timer2</title>
      <link href="/2022/09/15/STC89C52RC-Timer2/"/>
      <url>/2022/09/15/STC89C52RC-Timer2/</url>
      
        <content type="html"><![CDATA[<h1 id="Timer2-简述"><a href="#Timer2-简述" class="headerlink" title="Timer2 简述"></a>Timer2 简述</h1><pre><code>定时器2是一个16位定时器/计数器。其涉及的特殊寄存器如图</code></pre><img src = "https://s1.328888.xyz/2022/09/15/cUYd6.png" width= "75%"><h1 id="寄存器介绍"><a href="#寄存器介绍" class="headerlink" title="寄存器介绍"></a>寄存器介绍</h1><h2 id="T2CON"><a href="#T2CON" class="headerlink" title="T2CON"></a>T2CON</h2><pre><code>T2CON.7    TF2   定时器溢出标志。定时时间到将会由硬件置1，必须由软件清除。当RCLK(串口接收时钟)或TCLK(串口发送时钟)=1时，TF将不会置位(作为串口的时候不需要去清空)。T2CON.6    EXF2定时器外部标志。当EXEN2 = 1且T2EX的负跳变产生捕获或重装时。EXF2置位。定时器2中断使能时，EXF2 = 1将使CPU从中断向量处执行定时器2中断子程序。EXF2位必须用软件清零。在递增/递减计数器模式(DCEN=1)中，EXF2不会引起中断。T2CON.5    RCLK 接受时钟标志。RCLK置位时，定时器2溢出脉冲作为串口模式1和模式3的接收时钟。RCLK=0时，将定时器1的溢出脉冲作为串行口模式一和模式三的接收时钟。T2CON.4    TCLK 发送时钟标志。TCLK置位时，定时器2溢出脉冲作为串口模式1和模式3的发送时钟。TCLK=0时，将定时器1的溢出脉冲作为串行口模式一和模式三的发送时钟。T2CON.3    EXEN2 定时器2外部使能标志，当定时器未作串口时钟时，允许T2EX的负跳变产生捕获或重装。EXEN2=0时，T2EN跳变对定时器无效。T2CON.2    TR2 定时器2 启动/停止控制位。置1时 启动定时器。T2CON.1    C/_T2 定时器/计数器选择 (定时器2)0 内部定时器(SYSclk/12 或者 SYSclk/6)1 外部事件计数器(下降沿触发)T2CON.0    CP/_RL2捕获/重装标志。置位 EXEN2 = 1时，T2EX的负跳变产生捕获。清零 EXEN2 = 0时候，定时器2溢出或T2EX的负跳变都可以时定时器自动重装。当RCLK=1或者TCLK=1时，该位无效且定时器强制为溢出重装。</code></pre><h2 id="T2MOD"><a href="#T2MOD" class="headerlink" title="T2MOD"></a>T2MOD</h2><img src = "https://s1.328888.xyz/2022/09/15/cx9rd.png"><pre><code>总结：不要管</code></pre><h2 id="RCAP2L-x2F-RCAP2H"><a href="#RCAP2L-x2F-RCAP2H" class="headerlink" title="RCAP2L&#x2F;RCAP2H"></a>RCAP2L&#x2F;RCAP2H</h2><pre><code>8位 存储重装值</code></pre><h2 id="TL2-x2F-TH2"><a href="#TL2-x2F-TH2" class="headerlink" title="TL2&#x2F;TH2"></a>TL2&#x2F;TH2</h2><pre><code>8位 实际计数量一般格式:TL = RCAP2L = 溢出值        TH = RCAP2H = 溢出值&gt;&gt;8</code></pre><h1 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h1><img src = "https://s1.328888.xyz/2022/09/15/cx5IC.png"><h2 id="串口配置方法"><a href="#串口配置方法" class="headerlink" title="串口配置方法"></a>串口配置方法</h2><h3 id="溢出值计算方法"><a href="#溢出值计算方法" class="headerlink" title="溢出值计算方法"></a>溢出值计算方法</h3><img src = "https://s1.328888.xyz/2022/09/15/cxcDU.png"><pre><code>举例： 比如我要配置9600 使用的时11.0592MHZ 6t 的51单片机那么RCAP2H=RCAP2L = 65536 - [11059200/(16*96000)]=65536-72</code></pre><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码:"></a>实例代码:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">        11.0592Mhz   6t</span><br><span class="line"></span><br><span class="line">void UART_Init()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">//TMOD |= 0x20;  //T1工作模式2  8位自动重装</span><br><span class="line">//TH1 = 0xfd;</span><br><span class="line">//TL1 = 0xfd; //比特率9600</span><br><span class="line">//TR1 = 1;//启动T1 定时器</span><br><span class="line">//SM0 = 0;</span><br><span class="line">//SM1 = 1; //串口方式1 8位异步</span><br><span class="line">//REN = 1;//串口允许接收</span><br><span class="line"></span><br><span class="line">// 定时器1        11.0592   6t         9600</span><br><span class="line"></span><br><span class="line">SCON |= 0x50;  // 串口配置</span><br><span class="line"></span><br><span class="line">TL2 = RCAP2L = (65536 - 72);      //9600</span><br><span class="line">TH2 = RCAP2H = (65536 - 72)&gt;&gt;8;</span><br><span class="line"></span><br><span class="line">//TL2 = RCAP2L = (65536 - 6);       //115200</span><br><span class="line">//TH2 = RCAP2H = (65536 - 6)&gt;&gt;8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T2CON  = 0x34;   //定时器2配置</span><br><span class="line"></span><br><span class="line">EA  = 1;//总中断</span><br><span class="line">ES  = 1;//打开串口中断</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UART() interrupt 4</span><br><span class="line">&#123;</span><br><span class="line">if(RI)//是否接收完成</span><br><span class="line">&#123;</span><br><span class="line">num= SBUF; //读入缓存</span><br><span class="line">RI = 0;</span><br><span class="line">SBUF = num;</span><br><span class="line">while(!TI); //是否发送完成</span><br><span class="line">TI = 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> STC89C52RC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STC89C52RC </tag>
            
            <tag> Timer2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS</title>
      <link href="/2022/09/05/FreeRTOS/"/>
      <url>/2022/09/05/FreeRTOS/</url>
      
        <content type="html"><![CDATA[<h1 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h1><h2 id="不传递参数"><a href="#不传递参数" class="headerlink" title="不传递参数"></a>不传递参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">void task1(void *pt) &#123;</span><br><span class="line">  pinMode(23, OUTPUT);</span><br><span class="line">  while (1) &#123;</span><br><span class="line">    digitalWrite(23, !digitalRead(23));</span><br><span class="line">    /*</span><br><span class="line">      Tick to Time</span><br><span class="line">        pdMS_TO_TICKS</span><br><span class="line">        portTICK_PERIOD_MS</span><br><span class="line">      vTaskDelay(pdMS_TO_TICKS(1000));</span><br><span class="line">      vTaskDelay(1000/portTICK_PERIOD_MS);</span><br><span class="line">    */</span><br><span class="line">    vTaskDelay(1000); //注意 是 ticks的数量 不是时间</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void task2(void *pt) &#123;</span><br><span class="line">  pinMode(21, OUTPUT);</span><br><span class="line">  while (1) &#123;</span><br><span class="line">    digitalWrite(21, !digitalRead(21));</span><br><span class="line">    vTaskDelay(3000);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void setup() &#123;</span><br><span class="line">  Serial.begin(9600);</span><br><span class="line">  Serial.print(&quot;ESP32 Tick Period - &quot;);</span><br><span class="line">  Serial.print(portTICK_PERIOD_MS);</span><br><span class="line">  Serial.println(&quot;ms&quot;);</span><br><span class="line"></span><br><span class="line">  if (xTaskCreate(task1,</span><br><span class="line">                  &quot;Blink 23&quot;,</span><br><span class="line">                  1024,</span><br><span class="line">                  NULL,</span><br><span class="line">                  1,</span><br><span class="line">                  NULL) == pdPASS)</span><br><span class="line">    Serial.println(&quot;Task1 Created.&quot;);</span><br><span class="line"></span><br><span class="line">  if (xTaskCreate(task2,</span><br><span class="line">                  &quot;Blink 21&quot;,</span><br><span class="line">                  1024,</span><br><span class="line">                  NULL,</span><br><span class="line">                  1,</span><br><span class="line">                  NULL) == pdPASS)</span><br><span class="line">    Serial.println(&quot;Task2 Created.&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void loop() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="传递多参数"><a href="#传递多参数" class="headerlink" title="传递多参数"></a>传递多参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  byte pin;</span><br><span class="line">  int delayTime;</span><br><span class="line">&#125; LEDFLASH;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void ledFlash(void *pt) &#123;</span><br><span class="line">  LEDFLASH * ptLedFlash = (LEDFLASH *)pt;       //将传递的指针数据读出来</span><br><span class="line">  byte pin = ptLedFlash-&gt;pin;</span><br><span class="line">  int delayTime = ptLedFlash-&gt;delayTime;</span><br><span class="line"></span><br><span class="line">  pinMode(pin,OUTPUT);</span><br><span class="line">  while (1) &#123;</span><br><span class="line">    digitalWrite(pin, !digitalRead(pin));</span><br><span class="line">    vTaskDelay(delayTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">LEDFLASH led1, led2;</span><br><span class="line"></span><br><span class="line">void setup() &#123;</span><br><span class="line">  Serial.begin(9600);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  led1.pin = 23;                       //设置传递参数的值</span><br><span class="line">  led1.delayTime = 1000;</span><br><span class="line">  led2.pin = 21;</span><br><span class="line">  led2.delayTime = 3000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (xTaskCreate(ledFlash,      //xTaskCreate(任务,命名,分配的内存空间,传递的参数(void指针),操作的指针)</span><br><span class="line">                  &quot;FLASH LED&quot;,</span><br><span class="line">                  1024,</span><br><span class="line">                  (void *)&amp;led1,</span><br><span class="line">                  1,</span><br><span class="line">                  NULL) == pdPASS)</span><br><span class="line">    Serial.println(&quot;led1 flash task Created.&quot;);</span><br><span class="line"></span><br><span class="line">if (xTaskCreate(ledFlash,</span><br><span class="line">                  &quot;FLASH LED&quot;,</span><br><span class="line">                  1024,</span><br><span class="line">                  (void *)&amp;led2,</span><br><span class="line">                  1,</span><br><span class="line">                  NULL) == pdPASS)</span><br><span class="line">    Serial.println(&quot;led2 flash task Created.&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void loop() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="多任务上锁"><a href="#多任务上锁" class="headerlink" title="多任务上锁"></a>多任务上锁</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  语法：</span><br><span class="line">  SemaphoreHandle_t xHandler; 创建Handler</span><br><span class="line">  xHandler = xSemaphoreCreateMutex(); 创建一个MUTEX 返回NULL，或者handler</span><br><span class="line">  xSemaphoreGive(xHandler); 释放</span><br><span class="line">  xSemaphoreTake(xHanlder, timeout); 指定时间内获取信号量 返回pdPASS, 或者pdFAIL</span><br><span class="line"></span><br><span class="line">  理解方法：</span><br><span class="line">  MUTEX的工作原理可以想象成</span><br><span class="line">  共享的资源被锁在了一个箱子里，只有一把钥匙，有钥匙的任务才能对改资源进行访问</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 养成良好习惯，被多进程和中断调用的变量使用 volatile 修饰符</span><br><span class="line">volatile uint32_t inventory = 100; //总库存</span><br><span class="line">volatile uint32_t retailCount = 0; //线下销售量</span><br><span class="line">volatile uint32_t onlineCount = 0; //线上销售量</span><br><span class="line"></span><br><span class="line">SemaphoreHandle_t xMutexInventory = NULL; //创建信号量Handler</span><br><span class="line"></span><br><span class="line">TickType_t timeOut = 1000; //用于获取信号量的Timeout 1000 ticks</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void retailTask(void *pvParam) &#123;</span><br><span class="line">  while (1) &#123;</span><br><span class="line"></span><br><span class="line">    // 在timeout的时间内如果能够获取就继续</span><br><span class="line">    // 通俗一些：获取钥匙</span><br><span class="line">    if (xSemaphoreTake(xMutexInventory, timeOut) == pdPASS) &#123;</span><br><span class="line">      //被MUTEX保护的内容叫做 Critical Section</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      //以下实现了带有随机延迟的 inventory减1；</span><br><span class="line">      //等效为 inventory--； retailCount++；</span><br><span class="line">      uint32_t inv = inventory;</span><br><span class="line">      for (int i; i &lt; random(10, 100); i++) vTaskDelay(pdMS_TO_TICKS(i));</span><br><span class="line">      if (inventory &gt; 0) &#123;</span><br><span class="line">        inventory = inv - 1;</span><br><span class="line">        retailCount++;</span><br><span class="line"></span><br><span class="line">        //释放钥匙</span><br><span class="line">        xSemaphoreGive(xMutexInventory);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        //无法获取钥匙</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    vTaskDelay(100); //老板要求慢一些，客户升级后，可以再加快速度</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void onlineTask(void *pvParam) &#123;</span><br><span class="line">  while (1) &#123;</span><br><span class="line"></span><br><span class="line">    // 在timeout的时间内如果能够获取二进制信号量就继续</span><br><span class="line">    // 通俗一些：获取钥匙</span><br><span class="line">    if (xSemaphoreTake(xMutexInventory, timeOut) == pdPASS) &#123;</span><br><span class="line">      //被MUTEX保护的内容叫做 Critical Section</span><br><span class="line">      //以下实现了带有随机延迟的 inventory减1；</span><br><span class="line">      //等效为 inventory--； retailCount++；</span><br><span class="line">      uint32_t inv = inventory;</span><br><span class="line">      for (int i; i &lt; random(10, 100); i++) vTaskDelay(pdMS_TO_TICKS(i));</span><br><span class="line">      if (inventory &gt; 0) &#123;</span><br><span class="line">        inventory = inv - 1;</span><br><span class="line">        onlineCount++;</span><br><span class="line"></span><br><span class="line">        //释放钥匙</span><br><span class="line">        xSemaphoreGive(xMutexInventory);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        //无法获取钥匙</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    vTaskDelay(100); //老板要求慢一些，客户升级后，可以再加快速度</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void showTask(void *pvParam) &#123;</span><br><span class="line">  while (1) &#123;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Inventory : %d\n&quot;, inventory);</span><br><span class="line">    printf(&quot;  Retail : %d, Online : %d\n&quot;, retailCount, onlineCount);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (inventory == 0 ) &#123;</span><br><span class="line">      uint32_t totalSales = retailCount + onlineCount;</span><br><span class="line">      printf(&quot;-----SALES SUMMARY-----\n&quot;);</span><br><span class="line">      printf(&quot;  Total Sales:  %d\n&quot;, totalSales);</span><br><span class="line">      printf(&quot;  OverSales:  %d\n&quot;, 100 - totalSales);</span><br><span class="line">    &#125;</span><br><span class="line">    vTaskDelay(pdMS_TO_TICKS(1000));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void setup() &#123;</span><br><span class="line">  // put your setup code here, to run once:</span><br><span class="line">  Serial.begin(115200);</span><br><span class="line"></span><br><span class="line">  xMutexInventory = xSemaphoreCreateMutex(); //创建MUTEX</span><br><span class="line"></span><br><span class="line">  if (xMutexInventory == NULL) &#123;</span><br><span class="line">    printf(&quot;No Enough Ram, Unable to Create Semaphore.&quot;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    xTaskCreate(onlineTask,</span><br><span class="line">                &quot;Online Channel&quot;,</span><br><span class="line">                1024 * 4,</span><br><span class="line">                NULL,</span><br><span class="line">                1,</span><br><span class="line">                NULL);</span><br><span class="line">    xTaskCreate(retailTask,</span><br><span class="line">                &quot;Retail Channel&quot;,</span><br><span class="line">                1024 * 4,</span><br><span class="line">                NULL,</span><br><span class="line">                1,</span><br><span class="line">                NULL);</span><br><span class="line">    xTaskCreate(showTask,</span><br><span class="line">                &quot;Display Inventory&quot;,</span><br><span class="line">                1024 * 4,</span><br><span class="line">                NULL,</span><br><span class="line">                1,</span><br><span class="line">                NULL);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void loop() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FreeRTOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
            <tag> ESP32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web笔记</title>
      <link href="/2022/09/05/Web%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/09/05/Web%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>www : world wide web<br>万维网</p><p>速查:<br><a href="http://man.fishc.com/html5">http://man.fishc.com/html5</a></p><p><a href="http://man.fishc.com/css3">http://man.fishc.com/css3</a></p><p><a href="http://bbs.fishc.com/">http://bbs.fishc.com</a></p><p>HTML: 超文本标记语言</p><p>&lt;!&#x3D;DOCTYPE&gt;  用html5解析</p><p>h1 h2 h3 h4 标题大小</p><p> 定义了一个段落<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  窗口自适应</span><br></pre></td></tr></table></figure><p>ceo 搜索引擎优化</p><p>自动跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv = &quot;refresh&quot; content = &quot; 1 ; http://www.bilibili.com &quot;&gt;</span><br></pre></td></tr></table></figure><p>正常 html解析碰到脚本会停止解析html去解析脚本<br>我们可以通过<br>1 把脚本放后面<br>2 延迟执行脚本 加入defer (只对外部脚本生效)<br>3 异步执行脚本 async (外部脚本生效)<br>来让他延迟解析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;noscript&gt; ... &lt;/noscript&gt; 当不支持script时</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32HAL_RTC</title>
      <link href="/2022/08/27/STM32HAL-RTC/"/>
      <url>/2022/08/27/STM32HAL-RTC/</url>
      
        <content type="html"><![CDATA[<h1 id="RTC"><a href="#RTC" class="headerlink" title="RTC"></a>RTC</h1><pre><code>可由 Vbat 供电 不会被复位键复位日历 无法断电保存rtc.h 自己添加MX_RTC_Init();需要自己添加RTC.c 中的MX_RTC_Init(void)函数有:</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(HAL_RTCEx_BKUPRead(&amp;hrtc, RTC_BKP_DR1)!=0x5050)    //判断是否时第一次上电 (默认是0xffff) 如果不是0x5050 则是第一次 就给初始化数据 否则就继承之前的</span><br><span class="line">&#123;</span><br><span class="line"> HAL_RTCEx_BKUPWrite(&amp;hrtc, RTC_BKP_DR1, 0x5050);</span><br><span class="line">    </span><br><span class="line"> 最后在后面加个&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>存放数据 先定义一个RTC_DateTypeDef rtcTime ;然后调用HAL_RTC_GetTime(&amp;hrtc, &amp;rtcTime, RTC_FORMAT_BIN);读取数据printf(&quot;%02d:%02d:%02d\r\n&quot;,GetTime.Hours, GetTime.Minutes, GetTime.Seconds);</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HAL_PWR_EnableBkUpAccess();         //取消备份区写保护</span><br><span class="line"></span><br><span class="line">__HAL_RCC_BKP_CLK_ENABLE();         //使能电源始终pwr</span><br><span class="line"></span><br><span class="line">__HAL_RCC_RTC_ENABLE();</span><br></pre></td></tr></table></figure><pre><code>需要先读出 时间 再读出日期</code></pre><h2 id="BKP"><a href="#BKP" class="headerlink" title="BKP"></a>BKP</h2><pre><code>10个16位寄存器可保存20个字节用户应用数据后备寄存器 可由 Vbat 供电 不会被复位键复位</code></pre><h3 id="HAL-RTCEx-BKUPRead"><a href="#HAL-RTCEx-BKUPRead" class="headerlink" title="HAL_RTCEx_BKUPRead()"></a>HAL_RTCEx_BKUPRead()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  HAL_RTCEx_BKUPWrite</span><br><span class="line">* @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains</span><br><span class="line">*                the configuration information for RTC.</span><br><span class="line">* @param  BackupRegister: RTC Backup data Register number.</span><br><span class="line">*          This parameter can be: RTC_BKP_DRx where x can be from 1 to 10 (or 42) to</span><br><span class="line">*                                 specify the register (depending devices).</span><br><span class="line">* @retval Read value</span><br></pre></td></tr></table></figure><h3 id="HAL-RTCEx-BKUPWrite"><a href="#HAL-RTCEx-BKUPWrite" class="headerlink" title="HAL_RTCEx_BKUPWrite"></a>HAL_RTCEx_BKUPWrite</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  HAL_RTCEx_BKUPWrite</span><br><span class="line">* @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains</span><br><span class="line">*                the configuration information for RTC.</span><br><span class="line">* @param  BackupRegister: RTC Backup data Register number.</span><br><span class="line">*          This parameter can be: RTC_BKP_DRx where x can be from 1 to 10 (or 42) to</span><br><span class="line">*                                 specify the register (depending devices).</span><br><span class="line">* @param  Data: Data to be written in the specified RTC Backup data register.</span><br><span class="line">* @retval None</span><br></pre></td></tr></table></figure><pre><code>例子:    HAL_RTCEx_BKUPRead(&amp;hrtc, RTC_BKP_DR1)!=0x5050)     HAL_RTCEx_BKUPWrite(&amp;hrtc, RTC_BKP_DR1, 0x5050);</code></pre>]]></content>
      
      
      <categories>
          
          <category> STM32_HAL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> HAL </tag>
            
            <tag> RTC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互联网基础</title>
      <link href="/2022/08/27/%E4%BA%92%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/08/27/%E4%BA%92%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h1><pre><code>局域网查看自己局域网 cmd-&gt;ipconfigipv4  ipv6 地址网关 WiFi 本身自己 就像海关 连接国与国之间 网关 连接网络与网络之间联网后会被赋相对互联网的ip 地址-&gt;DNS服务器-&gt;ip-&gt;服务器</code></pre><h1 id="互联网知识"><a href="#互联网知识" class="headerlink" title="互联网知识"></a>互联网知识</h1><h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><pre><code>WiFi 无线终端模式  接入点模式  混合模式</code></pre><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><pre><code>TCP/UDP   TCP 稳健   UDP 快 网游/在线视频</code></pre><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><pre><code>HTTP/FTP/...HTTP 有请求/响应</code></pre><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h4><img src="https://s2.loli.net/2022/08/27/8aFslempTXbjrx5.png" ><h5 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h5><pre><code>GET / HTTP / 1.1读取 / HTTP协议版本1.1GET 读取 POST 发送 </code></pre><h5 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h5><pre><code>Host:www.taichi-maker.com 网站地址User-Agent：Mozilla....  用户信息Accept:text/html 支持的格式Accept-Lauguage: zh-CN,zh;q=0.8 支持的语言ACcept-Encoding：gzip，deflate，sdch 支持的压缩编码格式Connection：Keep-Alive 是否继续保持连接</code></pre><h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><img src="https://s2.loli.net/2022/08/27/B4kWIAlQywh7Uiz.png" ><h5 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h5><pre><code>HTTP/1.1 200 OK 200 成功代码HTTP/1.1 404 NOT FOUND404 未找到代码状态码:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">100~199：成功接收请求，要求客户端继续提交下一次请求才能完成整个处理过程。</span><br><span class="line"></span><br><span class="line">200~299：成功接收请求并已完成整个处理过程。常用200</span><br><span class="line"></span><br><span class="line">300~399：完成请求，客户需进一步细化请求。</span><br><span class="line"></span><br><span class="line">400~499：客户端的请求有错误，常用404和403(403的含义是权限不够，服务器拒绝访问。)</span><br><span class="line"></span><br><span class="line">500~599：服务器端出现错误，常用500</span><br></pre></td></tr></table></figure></code></pre><h5 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h5><pre><code>Content-Type: text/html; charset = UTF-8响应体内容 : HTML网页; 编码字符集格式UTF-8Content-Type: image/jpeg  相应格式为jpeg图像 </code></pre>]]></content>
      
      
      <categories>
          
          <category> 互联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> 互联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32HAL_EXTI</title>
      <link href="/2022/08/26/STM32HAL-EXTI/"/>
      <url>/2022/08/26/STM32HAL-EXTI/</url>
      
        <content type="html"><![CDATA[<h1 id="STM32外部中断通道"><a href="#STM32外部中断通道" class="headerlink" title="STM32外部中断通道"></a>STM32外部中断通道</h1><img src="https://s2.loli.net/2022/08/26/ySLWVwuMUBf5FgK.png" ><h1 id="STM32中断配置"><a href="#STM32中断配置" class="headerlink" title="STM32中断配置"></a>STM32中断配置</h1><img src="https://s2.loli.net/2022/08/26/6nGB4YMxp9hoWi2.png" ><h1 id="中断回调函数"><a href="#中断回调函数" class="headerlink" title="中断回调函数"></a>中断回调函数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)</span><br><span class="line"></span><br><span class="line">  * @param  GPIO_Pin: Specifies the pins connected EXTI line</span><br><span class="line">  * @retval None</span><br></pre></td></tr></table></figure><pre><code>例子:void HAL_GPIO_EXTI_Callback(uint16_t GPIO_PIN)&#123;    if(GPIO_PIN==KEY1_PIN)    &#123;     if(KEY_1())       &#123;          LED_1_Contrary();         &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> STM32_HAL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> HAL </tag>
            
            <tag> EXTI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32HAL_OLED移植</title>
      <link href="/2022/08/23/STM32HAL-OLED%E7%A7%BB%E6%A4%8D/"/>
      <url>/2022/08/23/STM32HAL-OLED%E7%A7%BB%E6%A4%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="HAL配置"><a href="#HAL配置" class="headerlink" title="HAL配置"></a>HAL配置</h1><img src = "https://s2.loli.net/2022/08/23/X7GtR6ajn1lgIY2.png"><h1 id="取模格式"><a href="#取模格式" class="headerlink" title="取模格式"></a>取模格式</h1><img src = "https://s2.loli.net/2022/08/23/vfU7gtaCjxeTdXE.png" width = "75%"><h1 id="简单做个效果"><a href="#简单做个效果" class="headerlink" title="简单做个效果"></a>简单做个效果</h1><img src = "https://s2.loli.net/2022/08/23/DVA6rW5uiCfGkFU.png" ><h1 id="主要更改部分"><a href="#主要更改部分" class="headerlink" title="主要更改部分"></a>主要更改部分</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define OLED_SCLK_Clr() HAL_GPIO_WritePin(GPIOA,GPIO_PIN_5,RESET) //GPIO_ResetBits(GPIOA,GPIO_Pin_5)//CLK</span><br><span class="line">#define OLED_SCLK_Set() HAL_GPIO_WritePin(GPIOA,GPIO_PIN_5,SET) //GPIO_SetBits(GPIOA,GPIO_Pin_5)</span><br><span class="line"></span><br><span class="line">#define OLED_SDIN_Clr() HAL_GPIO_WritePin(GPIOA,GPIO_PIN_7,RESET) //GPIO_ResetBits(GPIOA,GPIO_Pin_7)//DIN</span><br><span class="line">#define OLED_SDIN_Set() HAL_GPIO_WritePin(GPIOA,GPIO_PIN_7,SET) //GPIO_SetBits(GPIOA,GPIO_Pin_7)</span><br><span class="line"></span><br><span class="line">#define OLED_RST_Clr() HAL_GPIO_WritePin(GPIOB,GPIO_PIN_0,RESET) //GPIO_ResetBits(GPIOB,GPIO_Pin_0)//RES</span><br><span class="line">#define OLED_RST_Set() HAL_GPIO_WritePin(GPIOB,GPIO_PIN_0,SET) //GPIO_SetBits(GPIOB,GPIO_Pin_0)</span><br><span class="line"></span><br><span class="line">#define OLED_DC_Clr() HAL_GPIO_WritePin(GPIOB,GPIO_PIN_1,RESET) //GPIO_ResetBits(GPIOB,GPIO_Pin_1)//DC</span><br><span class="line">#define OLED_DC_Set() HAL_GPIO_WritePin(GPIOB,GPIO_PIN_1,SET) //GPIO_SetBits(GPIOB,GPIO_Pin_1)</span><br><span class="line">      </span><br><span class="line">#define OLED_CS_Clr()  HAL_GPIO_WritePin(GPIOA,GPIO_PIN_4,RESET) //GPIO_ResetBits(GPIOA,GPIO_Pin_4)//CS</span><br><span class="line">#define OLED_CS_Set()  HAL_GPIO_WritePin(GPIOA,GPIO_PIN_4,SET) //GPIO_SetBits(GPIOA,GPIO_Pin_4)</span><br></pre></td></tr></table></figure><h1 id="总体代码"><a href="#总体代码" class="headerlink" title="总体代码"></a>总体代码</h1><h2 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line">/* USER CODE BEGIN Header */</span><br><span class="line">/**</span><br><span class="line">  ******************************************************************************</span><br><span class="line">  * @file           : main.c</span><br><span class="line">  * @brief          : Main program body</span><br><span class="line">  ******************************************************************************</span><br><span class="line">  * @attention</span><br><span class="line">  *</span><br><span class="line">  * Copyright (c) 2022 STMicroelectronics.</span><br><span class="line">  * All rights reserved.</span><br><span class="line">  *</span><br><span class="line">  * This software is licensed under terms that can be found in the LICENSE file</span><br><span class="line">  * in the root directory of this software component.</span><br><span class="line">  * If no LICENSE file comes with this software, it is provided AS-IS.</span><br><span class="line">  *</span><br><span class="line">  ******************************************************************************</span><br><span class="line">  */</span><br><span class="line">/* USER CODE END Header */</span><br><span class="line">/* Includes ------------------------------------------------------------------*/</span><br><span class="line">#include &quot;main.h&quot;</span><br><span class="line">#include &quot;gpio.h&quot;</span><br><span class="line"></span><br><span class="line">/* Private includes ----------------------------------------------------------*/</span><br><span class="line">/* USER CODE BEGIN Includes */</span><br><span class="line">#include &quot;../../icode/OLED/oled.h&quot;</span><br><span class="line">/* USER CODE END Includes */</span><br><span class="line"></span><br><span class="line">/* Private typedef -----------------------------------------------------------*/</span><br><span class="line">/* USER CODE BEGIN PTD */</span><br><span class="line"></span><br><span class="line">/* USER CODE END PTD */</span><br><span class="line"></span><br><span class="line">/* Private define ------------------------------------------------------------*/</span><br><span class="line">/* USER CODE BEGIN PD */</span><br><span class="line">/* USER CODE END PD */</span><br><span class="line"></span><br><span class="line">/* Private macro -------------------------------------------------------------*/</span><br><span class="line">/* USER CODE BEGIN PM */</span><br><span class="line"></span><br><span class="line">/* USER CODE END PM */</span><br><span class="line"></span><br><span class="line">/* Private variables ---------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">/* USER CODE BEGIN PV */</span><br><span class="line"></span><br><span class="line">/* USER CODE END PV */</span><br><span class="line"></span><br><span class="line">/* Private function prototypes -----------------------------------------------*/</span><br><span class="line">void SystemClock_Config(void);</span><br><span class="line">/* USER CODE BEGIN PFP */</span><br><span class="line"></span><br><span class="line">/* USER CODE END PFP */</span><br><span class="line"></span><br><span class="line">/* Private user code ---------------------------------------------------------*/</span><br><span class="line">/* USER CODE BEGIN 0 */</span><br><span class="line"></span><br><span class="line">/* USER CODE END 0 */</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * @brief  The application entry point.</span><br><span class="line">  * @retval int</span><br><span class="line">  */</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">  /* USER CODE BEGIN 1 */</span><br><span class="line"></span><br><span class="line">  /* USER CODE END 1 */</span><br><span class="line"></span><br><span class="line">  /* MCU Configuration--------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span><br><span class="line">  HAL_Init();</span><br><span class="line"></span><br><span class="line">  /* USER CODE BEGIN Init */</span><br><span class="line"></span><br><span class="line">  /* USER CODE END Init */</span><br><span class="line"></span><br><span class="line">  /* Configure the system clock */</span><br><span class="line">  SystemClock_Config();</span><br><span class="line"></span><br><span class="line">  /* USER CODE BEGIN SysInit */</span><br><span class="line"></span><br><span class="line">  /* USER CODE END SysInit */</span><br><span class="line"></span><br><span class="line">  /* Initialize all configured peripherals */</span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line">  /* USER CODE BEGIN 2 */</span><br><span class="line">  OLED_Init();</span><br><span class="line">  OLED_Clear();</span><br><span class="line">  /* USER CODE END 2 */</span><br><span class="line"></span><br><span class="line">  /* Infinite loop */</span><br><span class="line">  /* USER CODE BEGIN WHILE */</span><br><span class="line">  while (1)</span><br><span class="line">  &#123;</span><br><span class="line">  OLED_ShowCHinese(0,1,7);</span><br><span class="line">  OLED_ShowCHinese(18,1,8);</span><br><span class="line">  OLED_ShowCHinese(36,1,9);</span><br><span class="line">  OLED_ShowCHinese(54,1,10);</span><br><span class="line">  OLED_ShowString(72,1,&quot;!&quot;);</span><br><span class="line">  OLED_ShowString(24,3,&quot;HelloWorld!&quot;);</span><br><span class="line">    /* USER CODE END WHILE */</span><br><span class="line"></span><br><span class="line">    /* USER CODE BEGIN 3 */</span><br><span class="line">  &#125;</span><br><span class="line">  /* USER CODE END 3 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * @brief System Clock Configuration</span><br><span class="line">  * @retval None</span><br><span class="line">  */</span><br><span class="line">void SystemClock_Config(void)</span><br><span class="line">&#123;</span><br><span class="line">  RCC_OscInitTypeDef RCC_OscInitStruct = &#123;0&#125;;</span><br><span class="line">  RCC_ClkInitTypeDef RCC_ClkInitStruct = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">  /** Initializes the RCC Oscillators according to the specified parameters</span><br><span class="line">  * in the RCC_OscInitTypeDef structure.</span><br><span class="line">  */</span><br><span class="line">  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;</span><br><span class="line">  RCC_OscInitStruct.HSEState = RCC_HSE_ON;</span><br><span class="line">  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;</span><br><span class="line">  RCC_OscInitStruct.HSIState = RCC_HSI_ON;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;</span><br><span class="line">  if (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /** Initializes the CPU, AHB and APB buses clocks</span><br><span class="line">  */</span><br><span class="line">  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK</span><br><span class="line">                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;</span><br><span class="line">  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;</span><br><span class="line">  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;</span><br><span class="line">  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;</span><br><span class="line">  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;</span><br><span class="line"></span><br><span class="line">  if (HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* USER CODE BEGIN 4 */</span><br><span class="line"></span><br><span class="line">/* USER CODE END 4 */</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * @brief  This function is executed in case of error occurrence.</span><br><span class="line">  * @retval None</span><br><span class="line">  */</span><br><span class="line">void Error_Handler(void)</span><br><span class="line">&#123;</span><br><span class="line">  /* USER CODE BEGIN Error_Handler_Debug */</span><br><span class="line">  /* User can add his own implementation to report the HAL error return state */</span><br><span class="line">  __disable_irq();</span><br><span class="line">  while (1)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  /* USER CODE END Error_Handler_Debug */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#ifdef  USE_FULL_ASSERT</span><br><span class="line">/**</span><br><span class="line">  * @brief  Reports the name of the source file and the source line number</span><br><span class="line">  *         where the assert_param error has occurred.</span><br><span class="line">  * @param  file: pointer to the source file name</span><br><span class="line">  * @param  line: assert_param error line source number</span><br><span class="line">  * @retval None</span><br><span class="line">  */</span><br><span class="line">void assert_failed(uint8_t *file, uint32_t line)</span><br><span class="line">&#123;</span><br><span class="line">  /* USER CODE BEGIN 6 */</span><br><span class="line">  /* User can add his own implementation to report the file name and line number,</span><br><span class="line">     ex: printf(&quot;Wrong parameters value: file %s on line %d\r\n&quot;, file, line) */</span><br><span class="line">  /* USER CODE END 6 */</span><br><span class="line">&#125;</span><br><span class="line">#endif /* USE_FULL_ASSERT */</span><br></pre></td></tr></table></figure><h2 id="oled-h"><a href="#oled-h" class="headerlink" title="oled.h"></a>oled.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __OLED_H</span><br><span class="line">#define __OLED_H   </span><br><span class="line">#include &quot;stdlib.h&quot;    </span><br><span class="line">#include &quot;stm32f1xx_hal.h&quot; </span><br><span class="line">#include &quot;main.h&quot; </span><br><span class="line">#define u8 unsigned  char</span><br><span class="line">#define u32  unsigned long int</span><br><span class="line">#define OLED_MODE 0</span><br><span class="line">#define SIZE 16</span><br><span class="line">#define XLevelL0x00</span><br><span class="line">#define XLevelH0x10</span><br><span class="line">#define Max_Column128</span><br><span class="line">#define Max_Row64</span><br><span class="line">#defineBrightness0xFF </span><br><span class="line">#define X_WIDTH 128</span><br><span class="line">#define Y_WIDTH 64    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define OLED_SCLK_Clr() HAL_GPIO_WritePin(GPIOA,GPIO_PIN_5,RESET) //GPIO_ResetBits(GPIOA,GPIO_Pin_5)//CLK</span><br><span class="line">#define OLED_SCLK_Set() HAL_GPIO_WritePin(GPIOA,GPIO_PIN_5,SET) //GPIO_SetBits(GPIOA,GPIO_Pin_5)</span><br><span class="line"></span><br><span class="line">#define OLED_SDIN_Clr() HAL_GPIO_WritePin(GPIOA,GPIO_PIN_7,RESET) //GPIO_ResetBits(GPIOA,GPIO_Pin_7)//DIN</span><br><span class="line">#define OLED_SDIN_Set() HAL_GPIO_WritePin(GPIOA,GPIO_PIN_7,SET) //GPIO_SetBits(GPIOA,GPIO_Pin_7)</span><br><span class="line"></span><br><span class="line">#define OLED_RST_Clr() HAL_GPIO_WritePin(GPIOB,GPIO_PIN_0,RESET) //GPIO_ResetBits(GPIOB,GPIO_Pin_0)//RES</span><br><span class="line">#define OLED_RST_Set() HAL_GPIO_WritePin(GPIOB,GPIO_PIN_0,SET) //GPIO_SetBits(GPIOB,GPIO_Pin_0)</span><br><span class="line"></span><br><span class="line">#define OLED_DC_Clr() HAL_GPIO_WritePin(GPIOB,GPIO_PIN_1,RESET) //GPIO_ResetBits(GPIOB,GPIO_Pin_1)//DC</span><br><span class="line">#define OLED_DC_Set() HAL_GPIO_WritePin(GPIOB,GPIO_PIN_1,SET) //GPIO_SetBits(GPIOB,GPIO_Pin_1)</span><br><span class="line">      </span><br><span class="line">#define OLED_CS_Clr()  HAL_GPIO_WritePin(GPIOA,GPIO_PIN_4,RESET) //GPIO_ResetBits(GPIOA,GPIO_Pin_4)//CS</span><br><span class="line">#define OLED_CS_Set()  HAL_GPIO_WritePin(GPIOA,GPIO_PIN_4,SET) //GPIO_SetBits(GPIOA,GPIO_Pin_4)</span><br><span class="line"></span><br><span class="line">#define OLED_CMD  0</span><br><span class="line">#define OLED_DATA 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void OLED_WR_Byte(u8 dat,u8 cmd);    </span><br><span class="line">void OLED_Display_On(void);</span><br><span class="line">void OLED_Display_Off(void);          </span><br><span class="line">void OLED_Init(void);</span><br><span class="line">void OLED_Clear(void);</span><br><span class="line">void OLED_DrawPoint(u8 x,u8 y,u8 t);</span><br><span class="line">void OLED_Fill(u8 x1,u8 y1,u8 x2,u8 y2,u8 dot);</span><br><span class="line">void OLED_ShowChar(u8 x,u8 y,u8 chr);</span><br><span class="line">void OLED_ShowNum(u8 x,u8 y,u32 num,u8 len,u8 size);</span><br><span class="line">void OLED_ShowString(u8 x,u8 y, u8 *p); </span><br><span class="line">void OLED_Set_Pos(unsigned char x, unsigned char y);</span><br><span class="line">void OLED_ShowCHinese(u8 x,u8 y,u8 no);</span><br><span class="line">void OLED_DrawBMP(unsigned char x0, unsigned char y0,unsigned char x1, unsigned char y1,unsigned char BMP[]);</span><br><span class="line">#endif  </span><br></pre></td></tr></table></figure><h2 id="oled-c"><a href="#oled-c" class="headerlink" title="oled.c"></a>oled.c</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;oled.h&quot;</span><br><span class="line">#include &quot;stdlib.h&quot;</span><br><span class="line">#include &quot;oledfont.h&quot;   </span><br><span class="line"></span><br><span class="line">#define delay_ms HAL_Delay</span><br><span class="line">//[0]0 1 2 3 ... 127</span><br><span class="line">//[1]0 1 2 3 ... 127</span><br><span class="line">//[2]0 1 2 3 ... 127</span><br><span class="line">//[3]0 1 2 3 ... 127</span><br><span class="line">//[4]0 1 2 3 ... 127</span><br><span class="line">//[5]0 1 2 3 ... 127</span><br><span class="line">//[6]0 1 2 3 ... 127</span><br><span class="line">//[7]0 1 2 3 ... 127    </span><br><span class="line"></span><br><span class="line">#if OLED_MODE==1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void OLED_WR_Byte(u8 dat,u8 cmd)</span><br><span class="line">&#123;</span><br><span class="line">DATAOUT(dat);    </span><br><span class="line">if(cmd)</span><br><span class="line">  OLED_DC_Set();</span><br><span class="line">else </span><br><span class="line">  OLED_DC_Clr();   </span><br><span class="line">OLED_CS_Clr();</span><br><span class="line">OLED_WR_Clr(); </span><br><span class="line">OLED_WR_Set();</span><br><span class="line">OLED_CS_Set();  </span><br><span class="line">OLED_DC_Set(); </span><br><span class="line">&#125;         </span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void OLED_WR_Byte(u8 dat,u8 cmd)</span><br><span class="line">&#123;</span><br><span class="line">u8 i;  </span><br><span class="line">if(cmd)</span><br><span class="line">  OLED_DC_Set();</span><br><span class="line">else </span><br><span class="line">  OLED_DC_Clr();  </span><br><span class="line">OLED_CS_Clr();</span><br><span class="line">for(i=0;i&lt;8;i++)</span><br><span class="line">&#123;  </span><br><span class="line">OLED_SCLK_Clr();</span><br><span class="line">if(dat&amp;0x80)</span><br><span class="line">   OLED_SDIN_Set();</span><br><span class="line">else </span><br><span class="line">   OLED_SDIN_Clr();</span><br><span class="line">OLED_SCLK_Set();</span><br><span class="line">dat&lt;&lt;=1;   </span><br><span class="line">&#125;   </span><br><span class="line">OLED_CS_Set();</span><br><span class="line">OLED_DC_Set();     </span><br><span class="line">&#125; </span><br><span class="line">#endif</span><br><span class="line">void OLED_Set_Pos(unsigned char x, unsigned char y) </span><br><span class="line">&#123; </span><br><span class="line">OLED_WR_Byte(0xb0+y,OLED_CMD);</span><br><span class="line">OLED_WR_Byte(((x&amp;0xf0)&gt;&gt;4)|0x10,OLED_CMD);</span><br><span class="line">OLED_WR_Byte((x&amp;0x0f)|0x01,OLED_CMD); </span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void OLED_Display_On(void)</span><br><span class="line">&#123;</span><br><span class="line">OLED_WR_Byte(0X8D,OLED_CMD);  //SET DCDC</span><br><span class="line">OLED_WR_Byte(0X14,OLED_CMD);  //DCDC ON</span><br><span class="line">OLED_WR_Byte(0XAF,OLED_CMD);  //DISPLAY ON</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void OLED_Display_Off(void)</span><br><span class="line">&#123;</span><br><span class="line">OLED_WR_Byte(0X8D,OLED_CMD);  //SET DCDC</span><br><span class="line">OLED_WR_Byte(0X10,OLED_CMD);  //DCDC OFF</span><br><span class="line">OLED_WR_Byte(0XAE,OLED_CMD);  //DISPLAY OFF</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">void OLED_Clear(void)  </span><br><span class="line">&#123;  </span><br><span class="line">u8 i,n;    </span><br><span class="line">for(i=0;i&lt;8;i++)  </span><br><span class="line">&#123;  </span><br><span class="line">OLED_WR_Byte (0xb0+i,OLED_CMD);</span><br><span class="line">OLED_WR_Byte (0x00,OLED_CMD);</span><br><span class="line">OLED_WR_Byte (0x10,OLED_CMD);</span><br><span class="line">for(n=0;n&lt;128;n++)OLED_WR_Byte(0,OLED_DATA); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void OLED_ShowChar(u8 x,u8 y,u8 chr)</span><br><span class="line">&#123;      </span><br><span class="line">unsigned char c=0,i=0;</span><br><span class="line">c=chr-&#x27; &#x27;;</span><br><span class="line">if(x&gt;Max_Column-1)&#123;x=0;y=y+2;&#125;</span><br><span class="line">if(SIZE ==16)</span><br><span class="line">&#123;</span><br><span class="line">OLED_Set_Pos(x,y);</span><br><span class="line">for(i=0;i&lt;8;i++)</span><br><span class="line">OLED_WR_Byte(F8X16[c*16+i],OLED_DATA);</span><br><span class="line">OLED_Set_Pos(x,y+1);</span><br><span class="line">for(i=0;i&lt;8;i++)</span><br><span class="line">OLED_WR_Byte(F8X16[c*16+i+8],OLED_DATA);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">OLED_Set_Pos(x,y+1);</span><br><span class="line">for(i=0;i&lt;6;i++)</span><br><span class="line">OLED_WR_Byte(F6x8[c][i],OLED_DATA);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u32 oled_pow(u8 m,u8 n)</span><br><span class="line">&#123;</span><br><span class="line">u32 result=1; </span><br><span class="line">while(n--)result*=m;    </span><br><span class="line">return result;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void OLED_ShowNum(u8 x,u8 y,u32 num,u8 len,u8 size)</span><br><span class="line">&#123;         </span><br><span class="line">u8 t,temp;</span><br><span class="line">u8 enshow=0;   </span><br><span class="line">for(t=0;t&lt;len;t++)</span><br><span class="line">&#123;</span><br><span class="line">temp=(num/oled_pow(10,len-t-1))%10;</span><br><span class="line">if(enshow==0&amp;&amp;t&lt;(len-1))</span><br><span class="line">&#123;</span><br><span class="line">if(temp==0)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowChar(x+(size/2)*t,y,&#x27; &#x27;);</span><br><span class="line">continue;</span><br><span class="line">&#125;else enshow=1; </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"> OLED_ShowChar(x+(size/2)*t,y,temp+&#x27;0&#x27;); </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void OLED_ShowString(u8 x,u8 y,u8 *chr)</span><br><span class="line">&#123;</span><br><span class="line">unsigned char j=0;</span><br><span class="line">while (chr[j]!=&#x27;\0&#x27;)</span><br><span class="line">&#123;OLED_ShowChar(x,y,chr[j]);</span><br><span class="line">x+=8;</span><br><span class="line">if(x&gt;120)&#123;x=0;y+=2;&#125;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void OLED_ShowCHinese(u8 x,u8 y,u8 no)</span><br><span class="line">&#123;          </span><br><span class="line">u8 t,adder=0;</span><br><span class="line">OLED_Set_Pos(x,y);</span><br><span class="line">    for(t=0;t&lt;16;t++)</span><br><span class="line">&#123;</span><br><span class="line">OLED_WR_Byte(Hzk[2*no][t],OLED_DATA);</span><br><span class="line">adder+=1;</span><br><span class="line">     &#125;</span><br><span class="line">OLED_Set_Pos(x,y+1);</span><br><span class="line">    for(t=0;t&lt;16;t++)</span><br><span class="line">&#123;</span><br><span class="line">OLED_WR_Byte(Hzk[2*no+1][t],OLED_DATA);</span><br><span class="line">adder+=1;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void OLED_DrawBMP(unsigned char x0, unsigned char y0,unsigned char x1, unsigned char y1,unsigned char BMP[])</span><br><span class="line">&#123; </span><br><span class="line"> unsigned int j=0;</span><br><span class="line"> unsigned char x,y;</span><br><span class="line">  </span><br><span class="line">  if(y1%8==0) y=y1/8;      </span><br><span class="line">  else y=y1/8+1;</span><br><span class="line">for(y=y0;y&lt;y1;y++)</span><br><span class="line">&#123;</span><br><span class="line">OLED_Set_Pos(x0,y);</span><br><span class="line">    for(x=x0;x&lt;x1;x++)</span><br><span class="line">    &#123;      </span><br><span class="line">    OLED_WR_Byte(BMP[j++],OLED_DATA);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void OLED_Init(void)</span><br><span class="line">&#123; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    OLED_RST_Set();</span><br><span class="line">delay_ms(100);</span><br><span class="line">OLED_RST_Clr();</span><br><span class="line">delay_ms(200);</span><br><span class="line">OLED_RST_Set(); </span><br><span class="line">  </span><br><span class="line">OLED_WR_Byte(0xAE,OLED_CMD);//--turn off oled panel</span><br><span class="line">OLED_WR_Byte(0x00,OLED_CMD);//---set low column address</span><br><span class="line">OLED_WR_Byte(0x10,OLED_CMD);//---set high column address</span><br><span class="line">OLED_WR_Byte(0x40,OLED_CMD);//--set start line address  Set Mapping RAM Display Start Line (0x00~0x3F)</span><br><span class="line">OLED_WR_Byte(0x81,OLED_CMD);//--set contrast control register</span><br><span class="line">OLED_WR_Byte(0xCF,OLED_CMD); // Set SEG Output Current Brightness</span><br><span class="line">OLED_WR_Byte(0xA1,OLED_CMD);//--Set SEG/Column Mapping    </span><br><span class="line">OLED_WR_Byte(0xC8,OLED_CMD);//Set COM/Row Scan Direction   </span><br><span class="line">OLED_WR_Byte(0xA6,OLED_CMD);//--set normal display</span><br><span class="line">OLED_WR_Byte(0xA8,OLED_CMD);//--set multiplex ratio(1 to 64)</span><br><span class="line">OLED_WR_Byte(0x3f,OLED_CMD);//--1/64 duty</span><br><span class="line">OLED_WR_Byte(0xD3,OLED_CMD);//-set display offsetShift Mapping RAM Counter (0x00~0x3F)</span><br><span class="line">OLED_WR_Byte(0x00,OLED_CMD);//-not offset</span><br><span class="line">OLED_WR_Byte(0xd5,OLED_CMD);//--set display clock divide ratio/oscillator frequency</span><br><span class="line">OLED_WR_Byte(0x80,OLED_CMD);//--set divide ratio, Set Clock as 100 Frames/Sec</span><br><span class="line">OLED_WR_Byte(0xD9,OLED_CMD);//--set pre-charge period</span><br><span class="line">OLED_WR_Byte(0xF1,OLED_CMD);//Set Pre-Charge as 15 Clocks &amp; Discharge as 1 Clock</span><br><span class="line">OLED_WR_Byte(0xDA,OLED_CMD);//--set com pins hardware configuration</span><br><span class="line">OLED_WR_Byte(0x12,OLED_CMD);</span><br><span class="line">OLED_WR_Byte(0xDB,OLED_CMD);//--set vcomh</span><br><span class="line">OLED_WR_Byte(0x40,OLED_CMD);//Set VCOM Deselect Level</span><br><span class="line">OLED_WR_Byte(0x20,OLED_CMD);//-Set Page Addressing Mode (0x00/0x01/0x02)</span><br><span class="line">OLED_WR_Byte(0x02,OLED_CMD);//</span><br><span class="line">OLED_WR_Byte(0x8D,OLED_CMD);//--set Charge Pump enable/disable</span><br><span class="line">OLED_WR_Byte(0x14,OLED_CMD);//--set(0x10) disable</span><br><span class="line">OLED_WR_Byte(0xA4,OLED_CMD);// Disable Entire Display On (0xa4/0xa5)</span><br><span class="line">OLED_WR_Byte(0xA6,OLED_CMD);// Disable Inverse Display On (0xa6/a7) </span><br><span class="line">OLED_WR_Byte(0xAF,OLED_CMD);//--turn on oled panel</span><br><span class="line"></span><br><span class="line">OLED_WR_Byte(0xAF,OLED_CMD); /*display ON*/ </span><br><span class="line">OLED_Clear();</span><br><span class="line">OLED_Set_Pos(0,0); </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> STM32_HAL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> HAL </tag>
            
            <tag> SPI </tag>
            
            <tag> OLED </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32HAL_SPI</title>
      <link href="/2022/08/22/STM32HAL-SPI/"/>
      <url>/2022/08/22/STM32HAL-SPI/</url>
      
        <content type="html"><![CDATA[<h1 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,uint32_t Timeout)</span><br><span class="line"></span><br><span class="line">  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains</span><br><span class="line">  *               the configuration information for SPI module.</span><br><span class="line">  * @param  pTxData pointer to transmission data buffer</span><br><span class="line">  * @param  pRxData pointer to reception data buffer</span><br><span class="line">  * @param  Size amount of data to be sent and received</span><br><span class="line">  * @param  Timeout Timeout duration</span><br><span class="line">  * @retval HAL status</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>例子:HAL_SPI_TransmitReceive(&amp;hspi2,&amp;TxData,&amp;Rxdata,1,1000)SPI2   发送地址 接收地址  数量(单位byte)  溢出时间</code></pre>]]></content>
      
      
      <categories>
          
          <category> STM32_HAL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> HAL </tag>
            
            <tag> SPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32HAL_DMA</title>
      <link href="/2022/08/22/STM32HAL-DMA/"/>
      <url>/2022/08/22/STM32HAL-DMA/</url>
      
        <content type="html"><![CDATA[<h1 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h1><p>所有包括DMA工作的项目需要把DMA初始化函数放到前面！</p>]]></content>
      
      
      <categories>
          
          <category> STM32_HAL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> DMA </tag>
            
            <tag> HAL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32HAL_ADC</title>
      <link href="/2022/08/21/STM32HAL_ADC/"/>
      <url>/2022/08/21/STM32HAL_ADC/</url>
      
        <content type="html"><![CDATA[<h1 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h1><h2 id="ADC校准"><a href="#ADC校准" class="headerlink" title="ADC校准"></a>ADC校准</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef* hadc); //先校准ADC</span><br><span class="line">  * @param  hadc: This parameter can be </span><br><span class="line">            1  &amp;hadc1</span><br><span class="line">            2  &amp;hadc2</span><br><span class="line">  * @retval HAL status</span><br></pre></td></tr></table></figure><pre><code>  例子:  HAL_ADCEx_Calibration_Start(&amp;hadc1);  </code></pre><h2 id="软件开启一次转换"><a href="#软件开启一次转换" class="headerlink" title="软件开启一次转换"></a>软件开启一次转换</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uint16_t ADC_IN_1(void) //ADC采集程序</span><br><span class="line">&#123;</span><br><span class="line">   HAL_ADC_Start(&amp;hadc1); //开始ADC采集</span><br><span class="line">   HAL_ADC_PollForConversion(&amp;hadc1,500); //等待采集结束</span><br><span class="line">   if(HAL_IS_BIT_SET(HAL_ADC_GetState(&amp;hadc1), HAL_ADC_STATE_REG_EOC)) //读取ADC完成标志位</span><br><span class="line">   &#123;</span><br><span class="line">     return HAL_ADC_GetValue(&amp;hadc1); //读出ADC数值</span><br><span class="line">   &#125;</span><br><span class="line">     return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="DMA连续转换"><a href="#DMA连续转换" class="headerlink" title="DMA连续转换"></a>DMA连续转换</h2><pre><code>1 开启ADC 连续转换模式(不然转换一次就关闭了)2 循坏模式 半字数据</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HAL_ADC_Start_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length)</span><br><span class="line"></span><br><span class="line">  * @param  hadc: ADC handle</span><br><span class="line">  * @param  pData: The destination Buffer address.</span><br><span class="line">  * @param  Length: The length of data to be transferred from ADC peripheral to memory.</span><br><span class="line">  * @retval None</span><br><span class="line"></span><br><span class="line">  DMA must be configured to transfer size: half word.</span><br></pre></td></tr></table></figure><pre><code>例子: HAL_ADC_Start_DMA(&amp;hadc1, (uint32_t *) &amp; a1, 1);  adc1   转入a1中  每次连续转换1个</code></pre>]]></content>
      
      
      <categories>
          
          <category> STM32_HAL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> HAL </tag>
            
            <tag> ADC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32HAL-USART</title>
      <link href="/2022/08/21/STM32HAL-USART/"/>
      <url>/2022/08/21/STM32HAL-USART/</url>
      
        <content type="html"><![CDATA[<h1 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h1><h2 id="uart-串口发送数据"><a href="#uart-串口发送数据" class="headerlink" title="uart 串口发送数据"></a>uart 串口发送数据</h2><h3 id="HAL-UART-Transmit-huart-pData-Size-Timeout"><a href="#HAL-UART-Transmit-huart-pData-Size-Timeout" class="headerlink" title="HAL_UART_Transmit(huart, pData, Size, Timeout)"></a>HAL_UART_Transmit(huart, pData, Size, Timeout)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Transmit(huart, pData, Size, Timeout)</span><br><span class="line"> * @param  huart This parameter can be </span><br><span class="line">                 1  &amp;huart1 </span><br><span class="line">                 2  &amp;huart2    </span><br><span class="line">                 3  &amp;huart3</span><br><span class="line">           Pointer to a UART_HandleTypeDef structure that contains</span><br><span class="line">           the configuration information for the specified UART module.</span><br><span class="line"> * @param  pData Pointer to data buffer (u8 or u16 data elements).</span><br><span class="line"> * @param  Size  Amount of data elements (u8 or u16) to be sent</span><br><span class="line"> * @param  Timeout Timeout duration</span><br><span class="line"> * @retval HAL status</span><br></pre></td></tr></table></figure><pre><code>Size 参数 也可使用 sizeof()函数例子:HAL_UART_Transmit(&amp;huart1, (uint8_t*)&amp;&quot;Hello\r\n&quot;, 7, 0xffff);</code></pre><h2 id="uart-串口接收数据"><a href="#uart-串口接收数据" class="headerlink" title="uart 串口接收数据"></a>uart 串口接收数据</h2><h3 id="HAL-UART-Receive-IT-UART-HandleTypeDef-huart-uint8-t-pData-uint16-t-Size"><a href="#HAL-UART-Receive-IT-UART-HandleTypeDef-huart-uint8-t-pData-uint16-t-Size" class="headerlink" title="HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)"></a>HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)</h3><pre><code>  注意：HAL 默认不开启串口接收,所以需要先调用此函数开启接收</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)</span><br><span class="line"></span><br><span class="line">  * @param  huart This parameter can be </span><br><span class="line">            1   &amp;huart1</span><br><span class="line">            2   &amp;huart2</span><br><span class="line">            3   &amp;huart3</span><br><span class="line">  * @param  pData Pointer to data buffer (u8 or u16 data elements).</span><br><span class="line">  * @param  Size  Amount of data elements (u8 or u16) to be received.</span><br><span class="line">  * @retval HAL status</span><br></pre></td></tr></table></figure><pre><code>      例:HAL_UART_Receive_IT(&amp;huart1,(uint8_t *) &amp;USART1_NewData ,1);   //开启串口1 接收数据(一个字节)存放到USART1_NewData数组</code></pre><h3 id="中断回调函数"><a href="#中断回调函数" class="headerlink" title="中断回调函数"></a>中断回调函数</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><pre><code>与标准库不同,HAL库在处理中断时中断函数里面只有最简单的中断来源触发中断后，中断函数跳转到&quot;中断回调函数&quot;执行用户的代码</code></pre><h4 id="void-HAL-UART-RxCpltCallback-UART-HandleTypeDef-huart"><a href="#void-HAL-UART-RxCpltCallback-UART-HandleTypeDef-huart" class="headerlink" title="void  HAL_UART_RxCpltCallback(UART_HandleTypeDef  *huart)"></a>void  HAL_UART_RxCpltCallback(UART_HandleTypeDef  *huart)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void  HAL_UART_RxCpltCallback(UART_HandleTypeDef  *huart)</span><br><span class="line"></span><br><span class="line">  * @param  huart  This parameter can be </span><br><span class="line">                   1  &amp;husart1</span><br><span class="line">                   2  &amp;husart2</span><br><span class="line">                   3  &amp;husatr3</span><br><span class="line">  * @retval None</span><br></pre></td></tr></table></figure><p>例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">          void  HAL_UART_RxCpltCallback(UART_HandleTypeDef  *huart)//串口中断回调函数</span><br><span class="line">&#123;</span><br><span class="line">if(huart ==&amp;huart1)//判断中断来源（串口1）</span><br><span class="line">    &#123;</span><br><span class="line">       printf(&quot;%c&quot;,USART1_NewData); //把收到的数据以 a符号变量 发送回电脑</span><br><span class="line">       if((USART1_RX_STA&amp;0x8000)==0)&#123;//接收未完成</span><br><span class="line">           if(USART1_RX_STA&amp;0x4000)&#123;//接收到了0x0d</span><br><span class="line">               if(USART1_NewData!=0x0a)USART1_RX_STA=0;//接收错误,重新开始</span><br><span class="line">               else USART1_RX_STA|=0x8000;   //接收完成了</span><br><span class="line">           &#125;else&#123; //还没收到0X0D</span><br><span class="line">               if(USART1_NewData==0x0d)USART1_RX_STA|=0x4000;</span><br><span class="line">               else&#123;</span><br><span class="line">                  USART1_RX_BUF[USART1_RX_STA&amp;0X3FFF]=USART1_NewData; //将收到的数据放入数组</span><br><span class="line">                  USART1_RX_STA++;  //数据长度计数加1</span><br><span class="line">                  if(USART1_RX_STA&gt;(USART1_REC_LEN-1))USART1_RX_STA=0;//接收数据错误,重新开始接收</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       HAL_UART_Receive_IT(&amp;huart1,(uint8_t *)&amp;USART1_NewData,1); //再开启接收中断</span><br><span class="line">    &#125;</span><br><span class="line">    if(huart ==&amp;huart2)//判断中断来源(串口2)</span><br><span class="line">    &#123;</span><br><span class="line">       if(RS485orBT)&#123;//当RS485orBT标志位为1时是RS485模式，为0时是蓝牙模式</span><br><span class="line">       USART2_RX_BUF[0]=USART2_NewData;//将接收到的数据放入缓存数组（因只用到1个数据，所以只存放在数据[0]位置）</span><br><span class="line">       USART2_RX_STA++;//数据接收标志位加1</span><br><span class="line">       &#125;else&#123;</span><br><span class="line">       printf(&quot;%c&quot;,USART2_NewData); //把收到的数据以 a符号变量 发送回电脑</span><br><span class="line">       &#125;</span><br><span class="line">       HAL_UART_Receive_IT(&amp;huart2,(uint8_t *)&amp;USART2_NewData, 1); //再开启接收中断</span><br><span class="line">    &#125;</span><br><span class="line">if(huart ==&amp;huart3)//判断中断来源（串口3：WIFI模块）</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%c&quot;,USART3_NewData); //把收到的数据以 a符号变量 发送回电脑</span><br><span class="line">HAL_UART_Receive_IT(&amp;huart3,(uint8_t *)&amp;USART3_NewData,1); //再开启接收中断 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="重写printf函数"><a href="#重写printf函数" class="headerlink" title="重写printf函数"></a>重写printf函数</h1><pre><code> 1  Core-&gt;Src syscalls.c 属性-&gt;c/c++ Bulid-&gt;勾选&quot;Exclude resource from bulid&quot; （将文件不编译） 2  Core-&gt;Inc 添加retarget.h Core-&gt;Src 添加retarget.c 3   开启USART1 RetargetInit(&amp;huart1); 初始化uart1 printf(&quot;xxx&quot;)函数 串口发送xxx字样</code></pre><h1 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h1><pre><code>__weak 前缀是弱函数前缀 当不被定义时弱函数本身编译当被同名函数定义后弱函数不被编译类似于java的函数重载</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> HAL </tag>
            
            <tag> USART </tag>
            
            <tag> 重写printf函数 </tag>
            
            <tag> __week </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32HAL库函数</title>
      <link href="/2022/08/20/STM32HAL%E5%BA%93%E5%87%BD%E6%95%B0/"/>
      <url>/2022/08/20/STM32HAL%E5%BA%93%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="延迟函数"><a href="#延迟函数" class="headerlink" title="延迟函数"></a>延迟函数</h1><pre><code>    毫秒级延迟</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_Delay(uint32_t Delay)</span><br></pre></td></tr></table></figure><pre><code>uint32_t Delay:  This parameter can be (0..2^32)retval:          None</code></pre><h1 id="GPIO口控制"><a href="#GPIO口控制" class="headerlink" title="GPIO口控制"></a>GPIO口控制</h1><pre><code>多个IO口设置同样的状态,可以使用 &#39;|&#39; 连接</code></pre><h2 id="GPIO-Write"><a href="#GPIO-Write" class="headerlink" title="GPIO_Write"></a>GPIO_Write</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_GPIO_WritePin(GPIOx, GPIO_Pin, PinState) </span><br></pre></td></tr></table></figure><pre><code>GPIOx:         where x can be (A..G depending on device used)GPIO_Pin :     This parameter can be one of GPIO_PIN_x where x can be (0..15)PinState :     This parameter can be one of the GPIO_PinState enum values:                1    GPIO_PIN_RESET: to clear the port pin  (0)                2    GPIO_PIN_SET: to set the port pin      (1)retval:     None</code></pre><h2 id="GPIO-Read"><a href="#GPIO-Read" class="headerlink" title="GPIO_Read"></a>GPIO_Read</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_GPIO_ReadPin(GPIOx, GPIO_Pin) </span><br></pre></td></tr></table></figure><pre><code>GPIOx:         where x can be (A..G depending on device used)GPIO_Pin :     This parameter can be one of GPIO_PIN_x where x can be (0..15)retval:        1    GPIO_PIN_RESET        (0)               2    GPIO_PIN_SET      (1)</code></pre><h1 id="USART"><a href="#USART" class="headerlink" title="USART"></a>USART</h1><h2 id="USART-Send"><a href="#USART-Send" class="headerlink" title="USART_Send"></a>USART_Send</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)</span><br><span class="line"></span><br><span class="line">  * @param  huart Pointer to a UART_HandleTypeDef structure that contains</span><br><span class="line">  *               the configuration information for the specified UART module.</span><br><span class="line">  * @param  pData Pointer to data buffer (u8 or u16 data elements).</span><br><span class="line">  * @param  Size  Amount of data elements (u8 or u16) to be sent</span><br><span class="line">  * @param  Timeout Timeout duration</span><br><span class="line">  * @retval HAL status</span><br></pre></td></tr></table></figure><pre><code>HAL_UART_Transmit(&amp;huart1, (uint8_t*)&amp;&quot;Hello\r\n&quot;, 7, 0xffff);</code></pre><h2 id="USART-receive"><a href="#USART-receive" class="headerlink" title="USART_receive"></a>USART_receive</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)</span><br><span class="line"></span><br><span class="line">  * @param  huart Pointer to a UART_HandleTypeDef structure that contains</span><br><span class="line">  *               the configuration information for the specified UART module.</span><br><span class="line">  * @param  pData Pointer to data buffer (u8 or u16 data elements).</span><br><span class="line">  * @param  Size  Amount of data elements (u8 or u16) to be received.</span><br><span class="line">  * @param  Timeout Timeout duration</span><br><span class="line">  * @retval HAL status</span><br></pre></td></tr></table></figure><pre><code>HAL_UART_Receive_IT(&amp;huart3,(uint8_t *)&amp;USART1_NewData,1);</code></pre><h1 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h1><h2 id="ADC校准"><a href="#ADC校准" class="headerlink" title="ADC校准"></a>ADC校准</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef* hadc); //先校准ADC</span><br><span class="line">  * @param  hadc: This parameter can be </span><br><span class="line">            1  &amp;hadc1</span><br><span class="line">            2  &amp;hadc2</span><br><span class="line">  * @retval HAL status</span><br></pre></td></tr></table></figure><pre><code>  例子:  HAL_ADCEx_Calibration_Start(&amp;hadc1);  </code></pre><h2 id="软件开启一次转换"><a href="#软件开启一次转换" class="headerlink" title="软件开启一次转换"></a>软件开启一次转换</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uint16_t ADC_IN_1(void) //ADC采集程序</span><br><span class="line">&#123;</span><br><span class="line">   HAL_ADC_Start(&amp;hadc1); //开始ADC采集</span><br><span class="line">   HAL_ADC_PollForConversion(&amp;hadc1,500); //等待采集结束</span><br><span class="line">   if(HAL_IS_BIT_SET(HAL_ADC_GetState(&amp;hadc1), HAL_ADC_STATE_REG_EOC)) //读取ADC完成标志位</span><br><span class="line">   &#123;</span><br><span class="line">     return HAL_ADC_GetValue(&amp;hadc1); //读出ADC数值</span><br><span class="line">   &#125;</span><br><span class="line">     return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="DMA连续转换"><a href="#DMA连续转换" class="headerlink" title="DMA连续转换"></a>DMA连续转换</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HAL_ADC_Start_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length)</span><br><span class="line"></span><br><span class="line">  * @param  hadc: ADC handle</span><br><span class="line">  * @param  pData: The destination Buffer address.</span><br><span class="line">  * @param  Length: The length of data to be transferred from ADC peripheral to memory.</span><br><span class="line">  * @retval None</span><br><span class="line"></span><br><span class="line">  DMA must be configured to transfer size: half word.</span><br></pre></td></tr></table></figure><pre><code>例子: HAL_ADC_Start_DMA(&amp;hadc1, (uint32_t *) &amp; a1, 1);  adc1   转入a1中  每次连续转换1个</code></pre><h1 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,uint32_t Timeout)</span><br><span class="line"></span><br><span class="line">  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains</span><br><span class="line">  *               the configuration information for SPI module.</span><br><span class="line">  * @param  pTxData pointer to transmission data buffer</span><br><span class="line">  * @param  pRxData pointer to reception data buffer</span><br><span class="line">  * @param  Size amount of data to be sent and received</span><br><span class="line">  * @param  Timeout Timeout duration</span><br><span class="line">  * @retval HAL status</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> STM32_HAL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> HAL </tag>
            
            <tag> HAL库函数 </tag>
            
            <tag> GPIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32HAL_RCC</title>
      <link href="/2022/08/20/STM32HAL-RCC/"/>
      <url>/2022/08/20/STM32HAL-RCC/</url>
      
        <content type="html"><![CDATA[<h1 id="时钟树"><a href="#时钟树" class="headerlink" title="时钟树"></a>时钟树</h1><h2 id="时钟树总体框架"><a href="#时钟树总体框架" class="headerlink" title="时钟树总体框架"></a>时钟树总体框架</h2><img src = "https://s1.328888.xyz/2022/08/20/B7MDI.png" width="85%"><h2 id="时钟来源"><a href="#时钟来源" class="headerlink" title="时钟来源"></a>时钟来源</h2><img src = "https://s1.328888.xyz/2022/08/20/B7gvK.png" width="75%"><h1 id="MCO"><a href="#MCO" class="headerlink" title="MCO"></a>MCO</h1><h2 id="MCO作用"><a href="#MCO作用" class="headerlink" title="MCO作用"></a>MCO作用</h2><pre><code>    MCO：对外输出时钟     可以用作多个设备高度同步完成任务</code></pre><h2 id="MCO配置"><a href="#MCO配置" class="headerlink" title="MCO配置"></a>MCO配置</h2><img src = "https://s1.328888.xyz/2022/08/20/B7P5j.png" width="75%">  ]]></content>
      
      
      <categories>
          
          <category> STM32_HAL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> HAL </tag>
            
            <tag> RCC </tag>
            
            <tag> MCO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeIde界面汉化</title>
      <link href="/2022/08/20/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E6%B1%89%E5%8C%96/"/>
      <url>/2022/08/20/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E6%B1%89%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<img src="https://s1.328888.xyz/2022/08/20/BGQUR.png" width="50%"><img src="https://s1.328888.xyz/2022/08/20/BGzLU.png" width="50%"><img src="https://s1.328888.xyz/2022/08/20/BG7CB.png" width="50%"><img src="https://s1.328888.xyz/2022/08/20/B7II6.png" width="50%">]]></content>
      
      
      <categories>
          
          <category> STM32_HAL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> HAL </tag>
            
            <tag> STM32CubeIde </tag>
            
            <tag> 图形化编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文章演示</title>
      <link href="/2022/08/18/%E6%96%87%E7%AB%A0Test/"/>
      <url>/2022/08/18/%E6%96%87%E7%AB%A0Test/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006RKGBpgy1h0egvklcc4j30lo0v6n3d.jpg" alt="我是图片标识"></p><p><img src="https://s1.328888.xyz/2022/08/19/B6s0d.jpg" alt="imgloc图床测试"></p><img src="https://s1.328888.xyz/2022/08/19/B6s0d.jpg" width="50%" height="25%" />另一种测试 width和height后面的50%就是根据窗口的大小以一定的比例显示图片，是以width方向为准，并保持纵横比的，换句话说，把设置width的部分去掉，height的值改为任意百分比，显示的图像都是原图大小<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><p> 123</p><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p> 123</p><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p> 1322</p><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><p> 1233</p><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><p> 123</p><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><p> 123</p><h3 id="三级标题-1"><a href="#三级标题-1" class="headerlink" title="三级标题"></a>三级标题</h3><p> 1322</p><h4 id="四级标题-1"><a href="#四级标题-1" class="headerlink" title="四级标题"></a>四级标题</h4><p> 1233</p><p>下面是代码块测试</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span> ()&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
